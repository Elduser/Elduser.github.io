<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eldus</title>
  
  <subtitle>Eldus的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://4ark.me/"/>
  <updated>2020-06-13T09:36:01.373Z</updated>
  <id>https://4ark.me/</id>
  
  <author>
    <name>Eldus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的2019年度总结</title>
    <link href="https://4ark.me/post/72566ae3.html"/>
    <id>https://4ark.me/post/72566ae3.html</id>
    <published>2019-12-29T05:38:00.000Z</published>
    <updated>2020-06-13T09:36:01.373Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    转眼一年时间又过去了，在这一年中，完成从一名学生到职场工作者的角色转换，那么就用本文来回顾一下在这年中我都做了些什么，得到哪些收获和成长，反思还有哪些做得不够好的，并在最后制定明年的目标。<br></div><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>转眼一年时间又过去了，在这一年中，完成从一名学生到职场工作者的角色转换，那么就用本文来回顾一下在这年中我都做了些什么，得到哪些收获和成长，反思还有哪些做得不够好的，并在最后制定明年的目标。</p><p>这是我写年度总结的第二年，先来看看我在去年的<a href="https://4ark.me/post/5330f5ce.html">总结</a>中为自己定下了哪些目标：</p><ul><li>对已学知识进行梳理、深挖，写出通俗易懂的文章</li><li>增加英语词汇量</li><li>在广州找一份心仪的工作</li></ul><p>下面从以下几个方面来总结今年我做了什么，得到哪些收获：</p><ul><li>博客文章</li><li>开源项目</li><li>工作</li><li>英语</li></ul><h2 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h2><p>今年一共写了 21 篇文章，分为几类：</p><ul><li>技术点讲解</li><li>项目中遇到的问题，解决方案</li><li>读书笔记</li><li>个人总结</li></ul><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><ol><li><p>正向反馈</p><p>通过在社区发表文章，收获一定的读者，不时也有人能指出一些不足之处，自己既能得到成长，也能帮助别人。</p></li><li><p>文章被转载</p><p>其实只要注明出处，我还是很乐意自己的文章被转载，这说明我的文章是有价值的，所以偶尔在自己关注的公众号上看自己的文章，心里还是觉得挺高兴的。</p></li><li><p>破千赞的文章</p><p>这篇<a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noopener">《在浏览器输入 URL 回车之后发生了什么（超详细版）》</a>在知乎上超过了一千的赞同数，着实让我惊喜了一下，虽然不可否认这类文章比较容易让人点赞（以后再读系列），但不管怎么说还是有成就感的，毕竟写这篇文章也是花费了将近三天时间。</p></li></ol><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>写博客不能太功利，还记得年初写了一篇 <a href="https://juejin.im/post/5c602ba6e51d457fc75f7d09" target="_blank" rel="noopener">《分享一些好用的网站》</a>在几天内获得数百赞，于是我又马上写了一篇类似的分享文章，试图复制之前的成功，但是后来我转变了心态，不能一味地为了迎合大众而写一些对自己没帮助的文章，希望每一篇文章都是经过沉淀、有意义的。</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p><img src="https://i.loli.net/2019/12/28/6KnUbjgMZPkXLwe.png" alt="image.png"></p><p>PS：56次提交那天是有故事的</p><h3 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h3><ol><li><p>第一个破百 star 的项目</p><p><a href="https://github.com/gd4Ark/star-battle" target="_blank" rel="noopener">star-battle</a> 是我第一个开源项目，我在初学前端的时候，写过很多小游戏，但完成这个游戏让我的编码能力得到质的提升，不过还是存在很多不足，希望明年能抽时间更新到 2.0 版本。</p></li><li><p>第一个开源组件</p><p><a href="https://github.com/gd4Ark/vue-fa-form" target="_blank" rel="noopener">vue-fa-form</a> 是经过几个项目沉淀下来的，起初只是集成在项目模板内部，后面将它独立出来，经历了从开发组件、编写文档，到发布，不过后来发现已经有更好的类似组件，所以后面也没继续维护，改向其他组件提 PR。</p></li><li><p>认识更多朋友</p><p>今年基本上是面向 GitHub 编程，不愧是全球最大的同性交友网站，通过这个平台我认识到几个朋友，甚至还成为了同事。</p></li></ol><h3 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h3><p>开源并不仅仅是开放源代码，它更是一种开放的精神，所以是不是自己的仓库并不重要，重要的是你有意愿参与其中，对此作出贡献。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>毕业后与几个小伙伴一起创业，主要是接一些外包项目，但过了几个月后感觉得不到提升，当时很迷茫，担心自己就这样止步不前，我开始思考我想要成为怎样的人，后来我找到了答案，写下<a href="https://4ark.me/post/a1f7df96.html">《我为什么会成为一名程序员》</a>，最终决定要换一个环境，并在我的<a href="https://4ark.me/post/27a6e4df.html">《面试总结》</a>中反思自己的不足和需要改进的地方。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>这个说来惭愧， 我的英语没怎么提升，主要原因是我没有坚持下去，不过在我换了家公司后有了改变，现在每天都会利用通勤时间背单词，相信慢慢地就会有提升。</p><h2 id="总结-2019"><a href="#总结-2019" class="headerlink" title="总结 2019"></a>总结 2019</h2><p>2019 年，我 19 岁，从校园到职场，开始了自己的职业生涯，对未来有过憧憬、有过迷茫，</p><p>刚出来工作，各方面都不太如意，但现在正慢慢步入正轨，相信一切都会好起来的，</p><p>无论如何，我不会停止前行的脚步。</p><h2 id="展望-2020"><a href="#展望-2020" class="headerlink" title="展望 2020"></a>展望 2020</h2><p>希望明年我能保持现在的习惯，不要停止在舒适区，更具体一点：</p><ul><li>写博客<ul><li>产出三篇以上高质量文章</li><li>掘金 LV5</li></ul></li><li>开源项目<ul><li>做一个好玩的项目</li><li>向大项目提 PR</li></ul></li><li>技术<ul><li>深入：看 Vue 全家桶源码</li><li>新技术：Flutter、K8s</li></ul></li><li>英语<ul><li>听说读写</li></ul></li><li>看书<ul><li>值得看的书</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    转眼一年时间又过去了，在这一年中，完成从一名学生到职场工作者的角色转换，那么就用本文来回顾一下在这年中我都做了些什么，得到哪些收获和成长，反思还有哪些做得不够好的，并在最后制定明年的目标。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="总结" scheme="https://4ark.me/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://4ark.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="https://4ark.me/post/27a6e4df.html"/>
    <id>https://4ark.me/post/27a6e4df.html</id>
    <published>2019-11-10T15:58:55.000Z</published>
    <updated>2020-06-13T09:36:01.380Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>经过前几天的面试，我从中有了一些感悟，让我觉得面试不仅仅是为了求得一份工作，也是一种自我审核的过程，它能让你意识到自身能力的不足，其中包括了你的：技术能力、沟通能力、表达能力、思考能力等。<br>所以我想把我的感悟写下来，从而更清晰地知道自身的不足，并且加以改进。<br></div><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>经过前几天的面试，我从中有了一些感悟，让我觉得面试不仅仅是为了求得一份工作，也是一个自我审核的过程，它能让你意识到自身能力的不足，其中包括了你的：技术能力、沟通能力、表达能力、思考能力等。</p><p>所以我想把我的感悟写下来，从而更清晰地知道自身的不足，并且加以改进。</p><h2 id="投简历"><a href="#投简历" class="headerlink" title="投简历"></a>投简历</h2><p>我起初是在拉勾网上海投简历，但大多都是石沉大海，之后我转向在BOOS直聘上投，依然大多都是回复不适合，仅有的几个面试机会，也是因为招聘人员是个技术，并且恰好点开了我的博客，给了我一个机会，我总结了一下，觉得主要是出在以下几个问题：学历、工作经验、技能。</p><p>说白了，在现在这个程序员满街跑的年代，大部分 HR 是不会看大专应届生的简历的，或者说我的简历在他们看来实在是没什么亮点，对于这个我也比较无奈，能做可能就是提升学历了。</p><p>而我能拿到面试机会，是因为技术人员看了我的博客、GitHub，这也让我们更加明白坚持写博客、写开源项目的好处。</p><h2 id="第一家公司"><a href="#第一家公司" class="headerlink" title="第一家公司"></a>第一家公司</h2><p>第一家公司只面了一次，总得来说面试官对我印象不错，但最后他说站在他个人的角度，认为我应该去更好的公司发展，说我很有潜力云云。</p><p>虽然他对我评价比较高，但我知道在那场面试中，我是没发挥好的，因为他问的大部分问题，我之前有写过文章，但是我依然没有很好地回答，总得来说有以下原因：</p><ul><li><p>准备不充分，偶尔会有遗漏</p></li><li><p>对知识点理解还不透彻，不能很直观的表达出来</p></li><li>比较紧张，回答问题不够清晰</li></ul><p>这让我知道我有必要重新梳理一遍知识点，但不再是仅仅依靠文字，还要口头表达出来。</p><p>最终我没有选择这家公司，因为我更倾向第二家。</p><h2 id="第二家公司"><a href="#第二家公司" class="headerlink" title="第二家公司"></a>第二家公司</h2><p>第二家公司一共面了三次，前两次是现场面，最后一次是电话面，三次面试大部分都不是考察知识点，更多是考察对技术的理解、个人素质、成长空间。</p><p>现场面试时，其实我也在观察他们，我在想如果以后我作为他们同事，我和他们是有一定差距的，这个差距不仅仅是技术，而是包括了：</p><ul><li><p>技术</p><p>包括了对技术的思考和理解、解决问题的方法和流程等。</p></li><li><p>个人素质</p><p>包括了沟通能力、英语能力、思考能力等。</p></li></ul><p>我能感觉到我们的差距，但我认为我和他们是同一类人，我有信心成为他们中的一员，不过我也知道他们的评价估计不怎么好，最后是他们老大决定再给我一次机会，再进行电话面试。</p><p>电话面试中，面试官问了我很多关于成长、学习、心态、兴趣的问题，我知道这是我最后的机会，我尽可能地展示最真实的自己，也没有刻意隐瞒自己的缺点。</p><p>最终我拿到了 offer，说起来也比较巧，我和他们团队刚好有共同的兴趣爱好，这也让我更坚信我们是同一类人，我会努力追上他们的脚步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我拿到了 offer，但是我知道我发挥不怎么好，从这次的面试经历中，发现了很多自身的问题，可能有些问题我之前就注意到了，但当时的环境让我产生了没必要改进的错觉，如今我深刻知道正是因为这些问题，才让我和别人产生差距，为了不让我落后于团队的人，我必须要有所行动。</p><p>主要有以下问题：</p><ul><li><p>思考能力</p><p>我缺少一个永远质疑的心态，这让我在做事情时，往往会停留在解决问题即可，可能会忽略了其他更优的解决方案。</p><p>这会造成我对大多事情的理解往往会停留于表面，而不能从容地整理各种解决方案的优缺点，比较孰优孰劣。</p><p>所以以后在解决问题时，要尝试别的可能性，即便当时条件不允许，事后也要重新复盘，养成习惯。</p></li><li><p>沟通能力</p><p>很多时候我不能清晰地表达自己的意思，这是因为我平时缺少了归纳总结，表达能力也欠缺。</p><p>这需要我前期大量的写作，养成能够条理清晰地描述问题的习惯，最后能够口头表达出来。</p><p>我可以做这些：</p><ul><li>归纳总结一些事情</li><li>把自己理解的知识写出来</li><li>简明扼要地复述一些书的内容</li><li>事后读出来，并且录下来，自己寻找问题</li></ul></li><li><p>英语能力</p><p>英语能力很重要，我之前认为英文只要能认出意思就行，不需要会读，这就发生了我在面试时想念某个单词却念不出的窘境，如果不克服这个问题，这种情况在以后工作中会经常出现。</p><p>所以我制定计划，按照赖世雄老师的课本，从头开始学英文。</p></li><li><p>写字能力</p><p>没错，由于我从小学开始就经常不写作业，导致我现在字丑不说，还经常会出现提笔忘字的情况，所以我也需要抄写文章，重拾我当年抛下的笔。</p></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>制定计划永远是简单的，我也曾制定过无数的计划，但真能如实执行的寥寥无几，因为之前的计划是没有督促力的，但这次我必须要执行，因为我不允许我落后于他们。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;经过前几天的面试，我从中有了一些感悟，让我觉得面试不仅仅是为了求得一份工作，也是一种自我审核的过程，它能让你意识到自身能力的不足，其中包括了你的：技术能力、沟通能力、表达能力、思考能力等。&lt;br&gt;所以我想把我的感悟写下来，从而更清晰地知道自身的不足，并且加以改进。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="总结" scheme="https://4ark.me/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://4ark.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>分享一些好用的网站（二）</title>
    <link href="https://4ark.me/post/839d1638.html"/>
    <id>https://4ark.me/post/839d1638.html</id>
    <published>2019-11-05T07:32:12.000Z</published>
    <updated>2020-06-13T09:36:01.377Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>半年前写了一篇<a href="https://4ark.me/post/a12c2740.html">《分享一些好用的网站》</a>记录了我之前常用的一些网站，现在过去半年，收藏夹也多了一些网站，特地记录下来，希望能对你有所帮助。<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105152931.png"><br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>半年前写了一篇<a href="https://4ark.me/post/a12c2740.html">《分享一些好用的网站》</a>记录了我之前常用的一些网站，现在过去半年，收藏夹也多了一些网站，特地记录下来，希望能对你有所帮助。</p><p>由于这些网站都比较杂，我也懒得分类了。</p><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><ol><li>临时邮箱 <a href="https://temp-mail.org/zh" target="_blank" rel="noopener">https://temp-mail.org/zh</a></li><li>域名注册商比较 <a href="https://www.nazhumi.com/domain/.com" target="_blank" rel="noopener">https://www.nazhumi.com/domain/.com</a></li><li>Tables Generator <a href="http://www.tablesgenerator.com/html_tables#" target="_blank" rel="noopener">http://www.tablesgenerator.com/html_tables#</a></li><li>图片放大 <a href="http://waifu2x.udp.jp/index.zh-CN.html" target="_blank" rel="noopener">http://waifu2x.udp.jp/index.zh-CN.html</a></li><li>物联网搜索引擎 <a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io</a></li><li>AST Explorer <a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net</a></li><li>Linux 命令搜索 <a href="http://git.io/linux" target="_blank" rel="noopener">http://git.io/linux</a></li><li>Vue render <a href="https://vuejs-tips.github.io/compiler/#inline-template" target="_blank" rel="noopener">https://vuejs-tips.github.io/compiler/#inline-template</a></li><li>图片转矢量图 <a href="https://www.vectorizer.io/" target="_blank" rel="noopener">https://www.vectorizer.io</a></li><li>在线免费作图 <a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com</a></li><li>拾色器 <a href="https://color.hailpixel.com/" target="_blank" rel="noopener">https://color.hailpixel.com</a></li><li>在线幻灯片 <a href="https://slides.com/" target="_blank" rel="noopener">https://slides.com</a></li></ol><h2 id="1、TempMail（临时邮箱）"><a href="#1、TempMail（临时邮箱）" class="headerlink" title="1、TempMail（临时邮箱）"></a>1、TempMail（临时邮箱）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105152931.png" alt></p><p>有时候注册某些论坛必须提供邮箱，但你又不想使用你常用的邮箱时，临时邮箱应运而生，在注册这些不重要的服务时使用临时邮箱作为替身是个很好的选择。临时邮箱具有匿名性，能有效减少垃圾邮件；同时具有时效性，邮箱在短时间内会自毁。</p><p>建议：</p><ul><li>使用完后手动删除邮件</li></ul><blockquote><p>网站链接：<a href="https://temp-mail.org/zh" target="_blank" rel="noopener">https://temp-mail.org/zh</a></p></blockquote><h2 id="2、哪煮米（域名注册商比价）"><a href="#2、哪煮米（域名注册商比价）" class="headerlink" title="2、哪煮米（域名注册商比价）"></a>2、哪煮米（域名注册商比价）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105153609.png" alt></p><p>当你想购买一个域名而不知道选哪个注册商时，这个网站可以帮助你对一些价格进行评分。</p><p>该站目前已经收录了58家域名注册商，可注册域名后缀将近有2000个，相关信息还在不断收集中。</p><blockquote><p>网站链接：<a href="https://www.nazhumi.com" target="_blank" rel="noopener">https://www.nazhumi.com</a></p></blockquote><h2 id="3、Table-Generator（表格生成）"><a href="#3、Table-Generator（表格生成）" class="headerlink" title="3、Table Generator（表格生成）"></a>3、Table Generator（表格生成）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105154026.png" alt></p><p>还记得我当时做一个项目，需要展示十几个不规则的报表，当时弄了一下午愣是没画出一个，终于让我发现这个网站，简直就是神器，只要像在 Excel 一样拽拉合并就可以直接生成 HTML 代码，顿时提高了百倍工作效率。</p><p>另外除了 HTML，它还支持：LaTeX、Text、Markdown等</p><blockquote><p>网站链接：<a href="http://www.tablesgenerator.com/html_tables" target="_blank" rel="noopener">http://www.tablesgenerator.com/html_tables</a></p></blockquote><h2 id="4、waifu2x（图片无损放大降噪）"><a href="#4、waifu2x（图片无损放大降噪）" class="headerlink" title="4、waifu2x（图片无损放大降噪）"></a>4、waifu2x（图片无损放大降噪）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105154646.png" alt></p><p>这个网站厉害了，可以将图片无损放大数倍，似乎是通过卷积神经网络等高科技（咱也不懂），反正好用就是了，如果以后刚好有这个需求，不妨用起来，亲测好用！</p><p>下面放一个对比图</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/下载.jpeg" alt></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/下载_waifu2x_art_noise1_scale_tta_1.png" alt></p><h2 id="5、shodan（物联网搜索引擎）"><a href="#5、shodan（物联网搜索引擎）" class="headerlink" title="5、shodan（物联网搜索引擎）"></a>5、shodan（物联网搜索引擎）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105160718.png" alt></p><p>首先，Shodan 是一个搜索引擎，但它与 Google 这种搜索网址的搜索引擎不同，Shodan 是用来搜索网络空间中在线设备的，你可以通过 Shodan 搜索指定的设备，或者搜索特定类型的设备。</p><p>好了，感兴趣的同学可以自行查阅资料，这里不好叙述过多。。</p><p>不过请不要做坏事哦。</p><blockquote><p>网站链接：<a href="https://www.shodan.io" target="_blank" rel="noopener">https://www.shodan.io</a></p></blockquote><h2 id="6、AST-Explorer（解析器生成AST）"><a href="#6、AST-Explorer（解析器生成AST）" class="headerlink" title="6、AST Explorer（解析器生成AST）"></a>6、AST Explorer（解析器生成AST）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105162317.png" alt></p><p>如果你在学习 AST 抽象语法树，那么这个网站很对你很有帮助，它可以展示将你输入的代码经过 parser 处理为AST 的过程。</p><blockquote><p>网站链接：<a href="https://astexplorer.net" target="_blank" rel="noopener">https://astexplorer.net</a></p></blockquote><h2 id="7、Linux-命令搜索"><a href="#7、Linux-命令搜索" class="headerlink" title="7、Linux 命令搜索"></a>7、Linux 命令搜索</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105163308.png" alt></p><p>有时候需要用到 Linux 命令但一时想不出去的时候，可以在上面搜一下，支持命令、描述搜索。</p><p>目前已收集 568 个命令，无聊时也可以上去看看，增加一下印象。</p><blockquote><p>网站链接：<a href="http://git.io/linux" target="_blank" rel="noopener">http://git.io/linux</a></p></blockquote><h2 id="8、Vue-render"><a href="#8、Vue-render" class="headerlink" title="8、Vue render"></a>8、Vue render</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105164607.png" alt></p><p>一个将 Vue HTML 编译为 JavaScript 的工具（有助于 Debug 和理解 Vue），深入学习 Vue 是如何把 HTML 编译成 JavaScript 有助于让你了解原理。</p><p>另外网站已经内置很多案例，可以快速查看一些内置指令在 render 函数中是如何编写的。</p><blockquote><p>网站链接：<a href="https://vuejs-tips.github.io/compiler/#inline-template" target="_blank" rel="noopener">https://vuejs-tips.github.io/compiler/#inline-template</a></p></blockquote><h2 id="9、Vectorizer（图片转矢量图）"><a href="#9、Vectorizer（图片转矢量图）" class="headerlink" title="9、Vectorizer（图片转矢量图）"></a>9、Vectorizer（图片转矢量图）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105165152.png" alt></p><p>该网站可以将位图转成矢量图（SVG），不仅支持PNG、BMP、JPEG格式，而且完全免费，亲测效果不错。</p><blockquote><p>网站链接：<a href="https://www.vectorizer.io" target="_blank" rel="noopener">https://www.vectorizer.io</a></p></blockquote><h2 id="10、processOn（免费在线作图）"><a href="#10、processOn（免费在线作图）" class="headerlink" title="10、processOn（免费在线作图）"></a>10、processOn（免费在线作图）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105165623.png" alt></p><p>ProcessOn 是一个在线协作绘图平台，为用户提供最强大、易用的作图工具！支持在线创作流程图、思维导图、组织结构图、网络拓扑图、BPMN、UML图、UI界面原型 …</p><p>之前做技术分享时用过一次，觉得挺不错的，免费版不支持直接导出高清图，解决方法就是先导入 SVG 再用别的工具转成 png。</p><p>但这个网站免费版只能在线存储9张图（包括回收站），目前的做法是先导入备份，有需要再导入。</p><p>这里推荐另外一个类似的网站 <a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>，不同之处在于：</p><ul><li>英文、可在线存储（利用 Google）、完全免费、不限数量</li></ul><p>所以如果是常用的话，建议还是使用 draw.io</p><blockquote><p>网站链接：<a href="https://processon.com" target="_blank" rel="noopener">https://processon.com</a></p></blockquote><h2 id="11、Colordot（拾色器）"><a href="#11、Colordot（拾色器）" class="headerlink" title="11、Colordot（拾色器）"></a>11、Colordot（拾色器）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105171134.png" alt></p><p>这个网站的特点就是通过摇动滑鼠轻松找出配色灵感，对于我这种不是很懂配色的人，以后就可以在上面挑几个比较顺眼的啦。</p><blockquote><p>网站链接：<a href="https://color.hailpixel.com" target="_blank" rel="noopener">https://color.hailpixel.com</a></p></blockquote><h2 id="12、Sliders（在线幻灯片）"><a href="#12、Sliders（在线幻灯片）" class="headerlink" title="12、Sliders（在线幻灯片）"></a>12、Sliders（在线幻灯片）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105171436.png" alt></p><p>可以在浏览器中创建在线幻灯片，轻松做出简洁实用的幻灯片，对于开发者需要制作技术分享文稿时是个不错的选择。</p><p>但 Sliders 的一些高级功能是要收费的，仅提供一些基本的使用，如果愿意折腾不妨使用这个  <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">Reveal.js</a>。</p><blockquote><p>网站链接：<a href="https://slides.com" target="_blank" rel="noopener">https://slides.com</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;半年前写了一篇&lt;a href=&quot;https://4ark.me/post/a12c2740.html&quot;&gt;《分享一些好用的网站》&lt;/a&gt;记录了我之前常用的一些网站，现在过去半年，收藏夹也多了一些网站，特地记录下来，希望能对你有所帮助。&lt;br&gt;&lt;img src=&quot;https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105152931.png&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="工具资源" scheme="https://4ark.me/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="https://4ark.me/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 与加密那些事儿</title>
    <link href="https://4ark.me/post/bebf2aea.html"/>
    <id>https://4ark.me/post/bebf2aea.html</id>
    <published>2019-11-04T09:57:45.000Z</published>
    <updated>2020-06-13T09:36:01.374Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>HTTPS 在我们日常中经常能用到，我们经常说 HTTPS 安全，那么你知道它为什么安全吗？有些同学会说：是因为加密啊，那么你知道它是怎么加密的吗？<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HTTPS 在我们日常中经常能用到，我们经常说 HTTPS 安全，那么你知道它为什么安全吗？有些同学会说：是因为加密啊，那么你知道它是怎么加密的吗？</p><p>如果你对此不是很明白，欢迎阅读本文，希望能让你解开 HTTPS 的迷雾，但如果你是大神级别的人物，那么请轻喷，因为我也不是很懂。。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>在说 HTTPS 之前，我们需要先知道 HTTP，HTTP 是基于 TCP 协议的一个无状态协议，如果你不是很懂欢迎阅读我上一篇文章，<a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么</a>，此文讲解了一个 HTTP 请求的过程。</p><p>缺点：</p><ol><li>使用明文进行传输，内容可能被窃听</li><li>不验证通信方的身份，通信方的身份可能是伪装</li><li>无法证明报文的完整性，报文有可能被篡改</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 并不是一个新协议，而是 HTTP 先和 <a href="SSL/TLS">SSL/TLS</a>，再由 SSL/TLS 和 TCP 通信。也就是说 HTTPS 使用了隧道进行通信。</p><p>为什么不直接对 HTTP 报文进行加密，而是多加一层 SSL/TLS  呢？因为 HTTP 报文分为报文首部和报文主体，如果只对发送内容进行加密（也就是报文主体），而未加密的报文首部信息也会导致信息不安全。</p><p>在开始讲之前我们需要介绍一下加密算法。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>加密算法的实现原理是公开的，读者可能觉得这观点很奇怪，很多开发者喜欢设计千奇百怪的算法，窃以为别人并不知道，其实自行设计的算法根本不具备严格的数学模型，很容易被攻破。流行的密码学算法其算法实现是公开的，经过了长时间的考验。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>简单来说就是加密和解密都是通过同一个密钥，比如我要传输的明文是 <code>5201314</code>，我在传输前将明文的所有数字+1，得到：<code>6302425</code>，然后接收方根据相同的密钥将密文进行解密，得到明文。</p><p>一般的对称加密算法是使用 XOR（异或） 这个特点，例如：</p><pre><code class="js">var a = 5201314 // 明文var b = 123456 // 密钥var c = a ^ b // 加密 var d = c ^ b // 解密 =&gt; 5201314 </code></pre><blockquote><p>如果对按位操作符感兴趣可以阅读我之前的文章：<a href="https://4ark.me/post/3953655a.html">深入理解按位操作符</a></p></blockquote><h4 id="一次性加密"><a href="#一次性加密" class="headerlink" title="一次性加密"></a>一次性加密</h4><p>上面这个例子就是一次性加密，在不知道密钥的情况下，理论上是无法破解，因为即便你遍历了所有情况，但由于你不确定破译出来的是不是原文，所以这就是它无法破解的原因。这个理论是香农(C.E.Shannon)于 1949 年通过数学方法加以证明的。</p><h4 id="DES-加密"><a href="#DES-加密" class="headerlink" title="DES 加密"></a>DES 加密</h4><p>DES 是 1977年美国联邦信息处理标准中采用的一种对称加密算法，但是在 1998 年已经被成功破解，耗时紧紧22小时，目前不再推荐使用。</p><p>它是一种把 64 位明文加密成 64 位密文的对称加密算法，也就是一次性只能加密 64 位，如果超过了 64 位，就需要进行分组加密。</p><p>对称加密还有很多种，想要了解更多可以查看这篇文章：<a href="https://halfrost.com/symmetric_encryption/" target="_blank" rel="noopener">漫游对称加密算法</a></p><h4 id="对称加密的缺点"><a href="#对称加密的缺点" class="headerlink" title="对称加密的缺点"></a>对称加密的缺点</h4><p>无论对称加密算法再怎么复杂，它们都有一个共同的弱点，就是</p><ul><li>如何传输密钥</li></ul><p>如果我们要和接收方进行通信，我们需要提前协商好一个密钥，那么这个如何才能保证密钥能安全地送达，而不会落到中间人手中？</p><p>自然是将密钥进行加密，但如何依然使用对称加密，那是不是又需要另外一个密钥？所以这就陷入死循环了。</p><p>这时候就要介绍密码学上伟大的发明：RSA（公钥私钥密码算法），也就是非对称加密算法。</p><h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><blockquote><p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做<a href="http://zh.wikipedia.org/zh-cn/RSA加密算法" target="_blank" rel="noopener">RSA算法</a>。</p></blockquote><p>非对称加密有公钥和私钥，也就是私钥加密的密文只有公钥才能解密，公钥加密的密文只有私钥才能解密。</p><p>关于原理部分我认为阮一峰老师的这篇文章<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理</a>已经讲得很通俗易懂了，这里不再赘述。</p><h4 id="非对称加密的缺点"><a href="#非对称加密的缺点" class="headerlink" title="非对称加密的缺点"></a>非对称加密的缺点</h4><p>非对称加密虽然安全，至今都无法被破解，但也不是完全没有缺点的，一个比较显著的缺点就是加密时需要经过大量的计算，消耗计算机资源。</p><h2 id="HTTPS-采用的加密方式"><a href="#HTTPS-采用的加密方式" class="headerlink" title="HTTPS 采用的加密方式"></a>HTTPS 采用的加密方式</h2><p>对称加密特点：</p><ul><li>优点：运算速度快</li><li>缺点：密钥容易被获取</li></ul><p>非对称加密特点：</p><ul><li>优点：更安全</li><li>缺点：运算速度慢</li></ul><p>很明显，如果 HTTPS 采用非对称加密的话，会消耗大量的计算资源，那么有没有一种方式可以解决这个问题呢？有的。</p><p>我们知道对称加密的缺点就是密钥的分发问题，既然这样，我们可以使用非对称加密对密钥进行加密，保证只有通信双方知道密钥后，接着就可以使用对称加密进行通信。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>但依然存在一个很严重的问题就是：<strong>公钥如何分发？</strong></p><p>因为客户端无法确认公钥是来自服务器还是来自中间人，所以需要一个客户端和服务器双方都信赖的第三方机构，配分配公钥，这个机构就叫做 数字证书认证机构（CA，Certificate Authority）。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。</p><p>但依然存在问题：<strong>证书怎么安全传输？ 被篡改了怎么办？</strong></p><p>使用数字签名就好了，简单来说就是将公钥和个人信息用一个 Hash 算法生成一个信息摘要。我们知道 Hash 算法有个极好的特征，只要输入的数据有一点点变化，那生成的信息摘要就会发生巨变，这样就可以防止别人修改原始内容。</p><p>但还有个问题就是，<strong>如何防止别人冒充 CA？</strong></p><p>如果连 CA 都无法信任的话，那么之前的一切都是徒劳的，所以必须打破僵局，我们必须信任 CA。</p><p>CA 是像树一样分级的，在操作系统/浏览器中都会内置一些顶层的 CA 证书，而这些顶层 CA 会为上层的 CA 做信用背书。</p><p>说到底其实我们相信的是操作系统/浏览器，如果中间人连这个都可以伪装，那么我们就没有安全可言了。</p><h2 id="HTTPS-中的-TLS-SSL-协议"><a href="#HTTPS-中的-TLS-SSL-协议" class="headerlink" title="HTTPS 中的 TLS / SSL 协议"></a>HTTPS 中的 TLS / SSL 协议</h2><blockquote><p>能让 HTTPS 带来安全性的是其背后的 TLS 协议。它源于九十年代中期在 Netscape 上开发的称为安全套接字层(SSL)的协议。到 20 世纪 90 年代末，Netscape 将 SSL 移交给了 IETF，IETF 将其重命名为 TLS，并从此成为该协议的管理者。许多人仍将 Web 加密称作 SSL，即使绝大多数服务已切换到仅支持 TLS。</p></blockquote><p>TLS/SSL 协议位于应用层和传输层 TCP 协议之间，注意 TLS/SSL 并不是只有 HTTP 才能使用，而是位于应用层的协议都可以使用，换句话说 TLS/SSL 协议 是用于加密应用层协议并传递给下层的 TCP。</p><p>TLS 粗略的划分又可以分为 2 层：</p><ul><li>靠近应用层的握手协议 TLS Handshaking Protocols</li><li>靠近 TCP 的记录层协议 TLS Record Protocol</li></ul><p>TLS 握手协议还能细分为 5 个子协议：</p><ul><li>change_cipher_spec (在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在)</li><li>alert</li><li>handshake</li><li>application_data</li><li>heartbeat (这个是 TLS 1.3 新加的，TLS 1.3 之前的版本没有这个协议)</li></ul><p>TLS/SSL 可以查看以下流程：</p><p><img src="https://i.loli.net/2019/11/05/ALpa2NBYJfsgi3c.png" alt></p><h3 id="握手失败"><a href="#握手失败" class="headerlink" title="握手失败"></a>握手失败</h3><p>浏览器访问 HTTPS 网站的时候，在握手阶段可能会存在错误，比如证书的有效期过期、证书是自签名证书、客户端和服务器无法协商出一致的密码套件，遇到类似的情况，浏览器会出现一个错误页面，告知用户存在的问题。</p><p>一般握手失败时，浏览器会直接告诉用户该网站不安全。</p><p>其实 TLS / SSL 协议的原理是很复杂的，如何感兴趣可以看一下《深入浅出 HTTPS》这本书。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>《深入浅出 HTTPS》</li><li><a href="https://halfrost.com/https-begin/" target="_blank" rel="noopener">HTTPS 温故知新</a></li><li><a href="https://halfrost.com/symmetric_encryption/" target="_blank" rel="noopener">漫游对称加密算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;HTTPS 在我们日常中经常能用到，我们经常说 HTTPS 安全，那么你知道它为什么安全吗？有些同学会说：是因为加密啊，那么你知道它是怎么加密的吗？&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://4ark.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="总结" scheme="https://4ark.me/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="系统" scheme="https://4ark.me/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="网络" scheme="https://4ark.me/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>我为什么会成为一名程序员</title>
    <link href="https://4ark.me/post/a1f7df96.html"/>
    <id>https://4ark.me/post/a1f7df96.html</id>
    <published>2019-10-27T08:18:43.000Z</published>
    <updated>2020-06-13T09:36:01.378Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    今天突发奇想，心里冒出一个很奇怪的问题：我为什么会成为一名程序员？<br>其实也是在问，我成为程序员的初心是什么？<br></div><a id="more"></a><p>今天突发奇想，心里冒出一个很奇怪的问题：我为什么会成为一名程序员？</p><p>其实也是在问，我成为程序员的初心是什么？</p><h2 id="接触电脑"><a href="#接触电脑" class="headerlink" title="接触电脑"></a>接触电脑</h2><p>第一次接触电脑应该是在小学四年级被同学带去网吧玩游戏，那时候对电脑的印象就是一台比较大的游戏机，从此以后我就成了一名网瘾少年，终日泡在网吧，但那时对于计算机的认识也只停留在玩游戏上。</p><p>不过这也让我从小对任何所接触的电子产品都感兴趣，到后来学会自己利用网上的教程去刷机、拆机等，总之那时就养成了比较爱折腾的习惯。</p><h2 id="初中辍学、读技校"><a href="#初中辍学、读技校" class="headerlink" title="初中辍学、读技校"></a>初中辍学、读技校</h2><p>初二那年我 14 岁，因为叛逆期的缘故，我辍学了，那时我就出来工作，我做过一些工厂的杂工、服务员等。</p><p>就这样过了两年，因为家人的劝说和自己也觉得需要重回学校学习，所以我还是决定回去读书。</p><p>因为从小对计算机感兴趣，所以选择了这个专业，现在看来，可能这是影响一生的决定。</p><h2 id="接触编程"><a href="#接触编程" class="headerlink" title="接触编程"></a>接触编程</h2><p>进入学校第三个学期，我才真正开始接触编程，那时候我们还没有相关的课程，只能自己学习，我开始接触 HTML、CSS，从此以后，我开始每天不孜不倦地学习，但那时候也没想过自己以后会从事这方面的工作，甚至连“程序员”、“前端开发”这些名称都没听说，但因为兴趣的缘故，我坚持了下来，那段时间没有一个同学和我交流，他们也不懂我做出一个看上去很难看的网页喜悦的心情。</p><h2 id="进入工作室"><a href="#进入工作室" class="headerlink" title="进入工作室"></a>进入工作室</h2><p>在第四个学期，我进入了学校的前端开发工作室，接触到比我厉害的师兄，我才真正明确以后要从事什么工作。</p><p>在不断的学习中，我经历了很多次从觉得自己很厉害、到发现其实自己懂得很少的阶段。</p><p>但我从来没有想过放弃编程，因为它确实改变了我的人生，而编程也能让我感到快乐，那是探索、创造的乐趣。</p><h2 id="工作之后"><a href="#工作之后" class="headerlink" title="工作之后"></a>工作之后</h2><p>之前我认为每个之所以成为程序员的人，都是因为对编程感兴趣，但后来发现也并不完全是，有些人的兴趣并不在此，他们做程序员的目的也不那么纯碎，可能是为了薪资高、为了谋生…</p><p>但我认为大部分程序员最初的目的肯定也是因为感兴趣使然，只是他们后来因为各种原因，忘记了最开始的初心。</p><p>我不想变成他们那样，但怎样才能让自己的初心不变呢？我思来想去，只有跟自己有共同想法的人一起工作，因为只有这样，我们可以一直督促自己前行。</p><h2 id="我的初心"><a href="#我的初心" class="headerlink" title="我的初心"></a>我的初心</h2><p>从我接触编程至今，我对技术始终保持浓烈的兴趣，虽然自知天资愚钝，但从未想过放弃。</p><p>我想即便不从事这个行业，我也会利用业余的时间来学习技术，当然现在更好的情况是，我可以以此当做职业。</p><p>因为当你的兴趣成为你的工作时，这是很幸福的。</p><p>我不要求自己以后成为什么技术大牛、架构师等等，只希望自己可以一直保持这份对技术的追求，这就足够了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>写这篇文章的原因，是为了复盘自己为何成为程序员，也是为了告诉未来的自己，不要忘记最开始的初心是什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    今天突发奇想，心里冒出一个很奇怪的问题：我为什么会成为一名程序员？&lt;br&gt;其实也是在问，我成为程序员的初心是什么？&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="总结" scheme="https://4ark.me/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://4ark.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如何打造自动化前端项目CLI 工具</title>
    <link href="https://4ark.me/post/2dfd4a9c.html"/>
    <id>https://4ark.me/post/2dfd4a9c.html</id>
    <published>2019-10-25T07:32:11.000Z</published>
    <updated>2020-06-13T09:36:01.377Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    在开发过程中，尤其是新开项目的时候，往往需要重新进行各种配置、甚至复制以往的代码，为了解决这种场景，就有了 CLI，想必大家平时都经常使用，比如 Vue 的<code>vue-cli</code>，React 的 <code>create-react-app</code>，这类工具存在的主要目的是：释放双手、加快项目开发进度。<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发过程中，尤其是新开项目的时候，往往需要重新进行各种配置、甚至复制以往的代码，为了解决这种场景，就有了 CLI，想必大家平时都经常使用，比如 Vue 的<code>vue-cli</code>，React 的 <code>create-react-app</code>，这类工具存在的主要目的是：释放双手、加快项目开发进度。</p><h2 id="我的场景"><a href="#我的场景" class="headerlink" title="我的场景"></a>我的场景</h2><p>本文就将介绍我如何根据我们团队内部的繁琐场景编写 CLI，从而加快项目开发速度。</p><p>开发项目中最常见的非后台管理系统莫属了，如果你仔细观察，就会发现大多数的后台管理大同小异。</p><p>就我们团队内部的后台管理系统而言，每次新开项目时，我们都需要进行以下操作：</p><ul><li>搭建项目：拷贝之前的项目来改，或者重新创建一个项目，再根据需求拷贝文件</li><li>新增页面的时候，需要创建很多文件（视图、路由、Vuex）</li></ul><p>而每个页面其实也是大同小异：</p><ul><li>数据表格（搜索、分页、其他操作等）</li><li>表单</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>基于以上场景，我想到的解决方法就是编写一个 CLI 工具，可以一行命令实现以下功能：</p><ul><li>初始化项目</li><li>增删页面</li></ul><p>只有 CLI 自然是不够的，还要搭配项目模板（template）使用。</p><p>但要注意脚手架工具要与项目模板解耦，下面细讲。</p><h3 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h3><p>创建一个 GitHub 组织存放项目模板，一个模板应该包含以下：</p><ol><li><p>meta.json</p><p>根据项目自定义一些问题，比如：</p><ul><li>项目名称</li><li>项目描述</li></ul></li><li><p>template 文件夹</p><p>存放项目模板，初始化时根据用户回答的问题，生成项目。</p></li><li><p>generator 文件夹</p><p>执行 CLI 命令时，由 CLI 调用，主要用来自定义一些问题、模板文件信息等。</p></li></ol><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>主要命令：</p><ol><li><p>init：</p><p>初始化项目，这时候会查询项目模板列表，然后根据用户所选的模板进行初始化（把项目模板下载到本地），并且生成一个<code>template.json</code>记录当前项目模板的名字，供后续使用</p></li><li><p>add、delete：</p><p>此命令需在生成后的项目中使用，会根据<code>template.json</code>中的模板信息找到对应的 <code>generator</code> 目录下的方法，执行对应的方法。</p></li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>每个团队面临的场景不一样，如果你也想编写一个自己的 CLI 工具，希望本文能给你提供一些思路。</p><p>如果有兴趣可以参考一下我的 CLI 实现：<a href="https://github.com/gd4Ark/fa-cli" target="_blank" rel="noopener">fa-cli</a>，项目模板：<a href="https://github.com/fa-web-template/vue-admin" target="_blank" rel="noopener">fa-web-template</a></p><p>感谢观看。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    在开发过程中，尤其是新开项目的时候，往往需要重新进行各种配置、甚至复制以往的代码，为了解决这种场景，就有了 CLI，想必大家平时都经常使用，比如 Vue 的&lt;code&gt;vue-cli&lt;/code&gt;，React 的 &lt;code&gt;create-react-app&lt;/code&gt;，这类工具存在的主要目的是：释放双手、加快项目开发进度。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://4ark.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器输入 URL 回车之后发生了什么（超详细版）</title>
    <link href="https://4ark.me/post/b6c7c0a2.html"/>
    <id>https://4ark.me/post/b6c7c0a2.html</id>
    <published>2019-08-22T11:08:15.000Z</published>
    <updated>2020-06-13T09:36:01.377Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，</p><p><strong>注意：</strong>本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h2 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h2><p><strong>地址解析：</strong></p><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p><strong>HSTS</strong></p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener">你所不知道的 HSTS</a>。</p><p><strong>其他操作</strong></p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p><strong>检查缓存</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181538.png" alt></p><h2 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h2><p><strong>基本步骤</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181732.png" alt></p><p><strong>1. 浏览器缓存</strong></p><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>2. 操作系统缓存</strong></p><p>操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>3. 路由器缓存</strong></p><p>路由器也有自己的缓存。</p><p><strong>4. ISP DNS 缓存</strong></p><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><p><strong>根域名服务器查询</strong></p><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1604181361-5a1397cca5644_articlex.png" alt></p><blockquote><p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">维基百科</a></p></blockquote><p><strong>需要注意的点</strong></p><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</li><li>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><h2 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h2><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822182400.png" alt></p><h3 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a><strong>1. 应用层：发送 HTTP 请求</strong></h3><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h3 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a><strong>2. 传输层：TCP 传输报文</strong></h3><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p><p>相关知识点：</p><ol><li>SYN 泛洪攻击</li></ol></blockquote><h3 id="3-网络层：IP协议查询Mac地址"><a href="#3-网络层：IP协议查询Mac地址" class="headerlink" title="3. 网络层：IP协议查询Mac地址"></a><strong>3. 网络层：IP协议查询Mac地址</strong></h3><p>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><h3 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a><strong>4. 链路层：以太网协议</strong></h3><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><p><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p><strong>注意</strong>：接收方回应是单播。</p><blockquote><p>相关知识点：</p><ol><li>ARP 攻击</li></ol></blockquote><h4 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a><strong>服务器接受请求</strong></h4><p>接受过程就是把以上步骤逆转过来，参见上图。</p><h2 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h2><p><strong>大致流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822183251.png" alt></p><p><strong>HTTPD</strong></p><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p><strong>处理请求</strong></p><p>接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><p><strong>重定向</strong></p><p>假如服务器配置了 HTTP 重定向，就会返回一个 <code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html" target="_blank" rel="noopener">详见这篇文章</a></p></blockquote><p><strong>URL 重写</strong></p><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h2 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h2><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">MIME</a> 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p><h2 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h2><p><strong>浏览器内核</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/961f7b5d-9e06-4006-ab99-974e8e9e2ba5.png" alt></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822183712.png" alt></p><h3 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1.HTML 解析"></a><strong>1.HTML 解析</strong></h3><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><p><strong>1. 解码（encoding）</strong></p><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p><p><strong>2. 预解析（pre-parsing）</strong></p><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p><p><strong>3. 符号化（Tokenization）</strong></p><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p><p><strong>4. 构建树（tree construction）</strong></p><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;h1&gt;Web page parsing&lt;/h1&gt;        &lt;p&gt;This is an example Web page.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1355879024-573db51949951_articlex.png" alt></p><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p><h3 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a>2. CSS 解析</h3><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href="https://drafts.csswg.org/css-syntax-3/" target="_blank" rel="noopener">语法规范</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><h3 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a>3. 渲染树</h3><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p><ol><li>标签名、class、id</li><li>是否内联样式</li><li><code>!important</code> </li></ol><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong></p><p>当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">这篇文章</a></p><h4 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a>4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a><strong>5. 合并渲染层</strong></h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a><strong>6. 回流与重绘</strong></h4><p><strong>回流(reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p><p>reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li></ul><h4 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h4><p><strong>大致流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822184523.png" alt></p><p>可以分为三个阶段：</p><h4 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a><strong>1. 词法分析</strong></h4><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将<code>var a = 2</code>，，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h4 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a><strong>2. 预编译</strong></h4><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong></p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<ul><li>参数、函数、变量</li></ul></li><li>建立作用域链<ul><li>确认当前执行环境是否能访问变量</li></ul></li><li>确定 This 指向</li></ul><h4 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a><strong>3. 执行</strong></h4><p><strong>JS 线程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822184731.png" alt></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong></p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li></ul><p><strong>微任务</strong></p><p>微任务是ES6和Node环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822185002.png" alt></p><p><strong>代码例子</strong></p><pre><code class="js">console.log(&#39;1&#39;); // 宏任务 同步setTimeout(function() {    console.log(&#39;2&#39;); // 宏任务 异步})new Promise(function(resolve) {    console.log(&#39;3&#39;); // 宏任务 同步    resolve();}).then(function() {    console.log(&#39;4&#39;) // 微任务})console.log(&#39;5&#39;) // 宏任务 同步</code></pre><p>以上代码输出顺序为：1,3,5,4,2</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></li><li><a href="https://alistapart.com/article/tags-to-dom/" target="_blank" rel="noopener">Tags to DOM</a></li><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li><li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">js引擎的执行过程（一）</a></li><li>还有一些找不到了。。。。。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://4ark.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="总结" scheme="https://4ark.me/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="系统" scheme="https://4ark.me/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="网络" scheme="https://4ark.me/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《图解 HTTP》 学习笔记</title>
    <link href="https://4ark.me/post/f6ef2a76.html"/>
    <id>https://4ark.me/post/f6ef2a76.html</id>
    <published>2019-08-18T16:20:15.000Z</published>
    <updated>2020-06-13T09:36:01.376Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>本书对互联网基盘——HTTP协议进行了全面系统的介绍。作者由HTTP协议的发展历史娓娓道来，严谨细致地剖析了HTTP协议的结构，列举诸多常见通信场景及实战案例，最后延伸到Web安全、最新技术动向等方面。本书的特色为在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解HTTP通信过程中客户端与服务器之间的交互情况。读者可通过本书快速了解并掌握HTTP协议的基础，前端工程师分析抓包数据，后端工程师实现REST API、实现自己的HTTP服务器等过程中所需的HTTP相关知识点本书均有介绍。<br><br>本书适合Web开发工程师，以及对HTTP协议感兴趣的各层次读者。<br></div><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本书对互联网基盘——HTTP协议进行了全面系统的介绍。作者由HTTP协议的发展历史娓娓道来，严谨细致地剖析了HTTP协议的结构，列举诸多常见通信场景及实战案例，最后延伸到Web安全、最新技术动向等方面。本书的特色为在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解HTTP通信过程中客户端与服务器之间的交互情况。读者可通过本书快速了解并掌握HTTP协议的基础，前端工程师分析抓包数据，后端工程师实现REST API、实现自己的HTTP服务器等过程中所需的HTTP相关知识点本书均有介绍。</p><p>本书适合Web开发工程师，以及对HTTP协议感兴趣的各层次读者。</p><h2 id="第一章、了解-WEB-及网络基础"><a href="#第一章、了解-WEB-及网络基础" class="headerlink" title="第一章、了解 WEB 及网络基础"></a>第一章、了解 WEB 及网络基础</h2><p><strong>HTTP 的诞生</strong></p><p>1989年3月，HTTP 诞生了，最初设想的理念是：借助多文本之间互相关联形成的超文本，连成 WWW。</p><p><strong>Web 成长时代</strong></p><p>1990年11月，CERN 研发了世界上第一台 WEB 服务器。</p><p>1990年，大家针对 HTML1.0 草案进行讨论，因存在多处模糊的地方，草案被直接废弃。</p><p>1992年9月，日本第一个<a href="http://www.ibarakiken.gr.jp/www/" target="_blank" rel="noopener">网站</a>的主页上线了。</p><p>1993年1月，现代浏览器的祖先 <a href="http://archive.ncsa.illinois.edu/mosaic.html" target="_blank" rel="noopener">Mosaic</a> 问世，它以内联等形式显示 HTML 的图像，迅速在世界范围内流行开来。</p><p>1994年12月，网景公司发布 Netscape Navigator 1.0。</p><p>1995年，微软发布了 Internet Explorer 1.0 和 2.0。</p><p><strong>驻足不前的 HTTP</strong></p><p>HTTP 0.9 ：因为那时的 HTTP 并没有正式的标准被建立，所有含有 HTTP 1.0 之前版本的意思。</p><p>HTTP 1.0 ：1996年5月正式作为标准被公布，并记载于 <a href="https://www.ietf.org/rfc/rfc1945.txt" target="_blank" rel="noopener">RFC1945</a>。</p><p>HTTP 1.1 ：1997年1月公布，最新标准版本为 <a href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">RFC2616</a>。</p><p><strong>网络基础 TCP/IP</strong></p><p>通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。</p><p><strong>TCP/IP 协议族</strong></p><p>TCP/IP 是互联网相关的各类协议族的总称。</p><p><strong>TCP/IP 的分层管理</strong></p><p>分为四层：</p><ul><li>应用层：决定了向用户提供应用服务时通信的活动，例如：FTP、DNS、HTTP。</li><li>传输层：提供处于网络连接中的两台计算机之间的数据传输，TCP、UDP。</li><li>网络层：处理在网络上流动的数据包，规定传输路线。</li><li>数据链路层：处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡及光纤等物理可见部分。</li></ul><p>分层的好处：把各层之间的接口部分规划好后，修改某个地方时只需修改对应的层，每个层次内部不影响其他层。</p><p><strong>TCP/IP 通信传输流</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819113915.png" alt></p><p>HTTP 举例：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819115726.png" alt></p><p><strong>与 HTTP 关系密切的协议 : IP、TCP 和DNS</strong></p><ul><li>负责传输的 IP 协议</li></ul><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143752.png" alt></p><ul><li><p>确保可靠性的 TCP 协议</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143845.png" alt></p></li><li><p>负责域名解析的 DNS 服务</p></li></ul><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143832.png" alt></p><p><strong>各种协议与 HTTP 协议的关系</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143952.png" alt></p><h2 id="第二章、简单的-HTTP-协议"><a href="#第二章、简单的-HTTP-协议" class="headerlink" title="第二章、简单的 HTTP 协议"></a>第二章、简单的 HTTP 协议</h2><p>HTTP 协议用于客户端和服务器之间的通信，请求资源方成为客户端，提供资源响应方成为服务器端。</p><p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p><p>请求报文的构成：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819145113.png" alt></p><p>响应报文的构成：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819145201.png" alt></p><p><strong>HTTP 是不保存状态的协议</strong></p><p>HTTP 是一个无状态协议，自身不具备保存之前发送过的请求或响应的功能。</p><p>之后随着发展，引入了 Cookie 技术。</p><p><strong>请求 URI 定位资源</strong></p><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p><p><strong>告知服务器意图的 HTTP 方法</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819150110.png" alt></p><p><strong>持久连接节省通信量</strong></p><p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。</p><p><strong>持久连接</strong></p><p>为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接的方法。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p><strong>管线化</strong></p><p>管线化技术出现后，能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><p><strong>使用 Cookie 的状态管理</strong></p><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><h2 id="第三章、HTTP-报文内的-HTTP信息"><a href="#第三章、HTTP-报文内的-HTTP信息" class="headerlink" title="第三章、HTTP 报文内的 HTTP信息"></a>第三章、HTTP 报文内的 HTTP信息</h2><p><strong>HTTP 报文</strong></p><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。</p><p>HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p><p>HTTP 报文大致可分为报文首部和报文主体两块，通常，并不一定要有报文主体。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819151451.png" alt></p><p><strong>结构</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819151537.png" alt></p><p><strong>实例</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819151613.png" alt></p><p><strong>编码提升传输速率</strong></p><p>HTTP 在传输时可以原样直接传输，也可以在传输时通过编码提升传输速率，通过编码，能有效地处理大量的访问请求，但也消耗更多的 CPU 等资源。</p><p><strong>报文主体和实体主体的差异</strong></p><ul><li>报文：HTTP 通信中的基本单位，由8位组字节流组成，通过 HTTP 通信传输。</li><li>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</li></ul><p><strong>压缩传输的内容编码</strong></p><p>常用的内容编码有以下几种：</p><ul><li>gzip（GNU zip）</li><li>compress（UNIX 系统的标准压缩）</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ul><p><strong>分割发送的分块传输编码</strong></p><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面，这种把实体主体分块的功能称为分块传输编码。</p><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。</p><p><strong>发送多种数据的多部分对象集合</strong></p><p>发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p><p>多部分对象集合包含的对象如下：</p><ul><li>multipart/form-data：在 Web 表单文件上传时使用。</li><li>multipart/byteranges：状态码 206，响应报文包含了多个范围的内容时使用。</li></ul><p><strong>获取部分内容的范围请求</strong></p><p>为了解决加载超大图片导致网络中断的情况而实现的一种手段，叫做范围请求。</p><p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819154030.png" alt></p><p><strong>内容协商返回最合适的内容</strong></p><p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商。</p><h2 id="第四章、返回结果的状态码"><a href="#第四章、返回结果的状态码" class="headerlink" title="第四章、返回结果的状态码"></a>第四章、返回结果的状态码</h2><p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p><p><strong>状态码类别</strong>：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819154239.png" alt></p><p>更多：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP 响应代码</a></p><h2 id="第五章、与-HTTP-协作的-Web-服务器"><a href="#第五章、与-HTTP-协作的-Web-服务器" class="headerlink" title="第五章、与 HTTP 协作的 Web 服务器"></a>第五章、与 HTTP 协作的 Web 服务器</h2><p> <strong>用单台虚拟主机实现多个域名</strong></p><p>即便物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以搭建多个站点。</p><p><strong>通信数据转发程序：代理、网关、隧道</strong></p><p>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序：</p><ul><li>代理：一种有转发功能的应用程序，扮演了服务器和客户端中间人的角色。</li><li>网关：转发其他服务器通信数据的服务器，它就像自己拥有资源的源服务器一样对请求进行处理。</li><li><p>隧道：将相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p><p><strong>保存资源的缓存</strong></p></li></ul><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p><strong>客户端的缓存</strong></p><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件。</p><h2 id="第六章、HTTP-首部"><a href="#第六章、HTTP-首部" class="headerlink" title="第六章、HTTP 首部"></a>第六章、HTTP 首部</h2><p><strong>注：这部分太多解释，建议看原文</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819155354.png" alt></p><p><strong>HTTP 请求报文</strong></p><p>在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819155327.png" alt></p><p><strong>HTTP 响应报文</strong></p><p>在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819155514.png" alt></p><p><strong>HTTP/1.1 首部字段一览</strong></p><p>通用首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160353.png" alt></p><p>请求首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160426.png" alt></p><p>响应首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160452.png" alt></p><p>实体首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160511.png" alt></p><h2 id="第七章、HTTP-的缺点"><a href="#第七章、HTTP-的缺点" class="headerlink" title="第七章、HTTP 的缺点"></a>第七章、HTTP 的缺点</h2><p>主要的不足，例举如下：</p><ul><li>通信使用明文（不加密），内容可能会被窃听（例如：抓包）</li><li>不验证通信方的身份，因此有可能遭遇伪装（例如：DoS）</li><li>无法证明报文的完整性，所以有可能已遭篡改（例如：中间人攻击）</li></ul><p><strong>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</strong></p><p>为了统一解决上述这些问题，需要在 HTTP 等机制。我们把添加了加密及认证机制的称为 HTTPS。</p><p><strong>使用 HTTPS 通信</strong></p><p>经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。</p><p><strong>HTTPS 是身披 SSL 外壳的 HTTP</strong></p><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。</p><p>简言之，所谓 HTTPS，其实就是身披SSL 协议这层外壳的 HTTP。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819161403.png" alt></p><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p><p><strong>相互交换密钥的公开密钥加密技术</strong></p><p>SSL 采用一种叫做公开密钥加密（非对称加密）的加密处理方式。</p><p><strong>HTTPS 的安全通信机制</strong></p><p>通信步骤：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819161648.png" alt></p><p><strong>SSL 速度慢吗</strong></p><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p><p>HTTPS 比 HTTP 要慢 2 到 100 倍，因为与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。</p><h2 id="第八章、确认访问用户身份的认证"><a href="#第八章、确认访问用户身份的认证" class="headerlink" title="第八章、确认访问用户身份的认证"></a>第八章、确认访问用户身份的认证</h2><p> <strong>何为认证</strong></p><p>服务器为了确认用户的身份，通常需要核对一些信息：</p><ul><li>密码</li><li>动态令牌</li><li>数字证书</li><li>生物认证</li><li>IC 卡</li></ul><p><strong>HTTP 使用的认证方式</strong></p><ul><li>BASIC 认证（基本认证）</li><li>DIGEST 认证（摘要认证）</li><li>SSL 客户端认证</li><li>FormBase 认证（基于表单认证）</li></ul><h2 id="第九章、基于-HTTP-的功能追加协议"><a href="#第九章、基于-HTTP-的功能追加协议" class="headerlink" title="第九章、基于 HTTP 的功能追加协议"></a>第九章、基于 HTTP 的功能追加协议</h2><p><strong>消除 HTTP 瓶颈的 SPDY</strong></p><p>Google 在 2010 年发布了 <a href="http://www.chromium.org/spdy/" target="_blank" rel="noopener">SPDY</a>（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p><p><strong>SPDY 的目标</strong></p><p>陆续出现的 Ajax 和 Comet 等提高易用性的技术，一定程度上使 HTTP得到了改善，但 HTTP 协议本身的限制也令人有些束手无策。为了进行根本性的改善，需要有一些协议层面上的改动。</p><p>处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP所遭遇的瓶颈。</p><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><ul><li>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。</li><li>赋予请求优先级：可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li>压缩 HTTP 首部</li><li>推送功能：支持服务器主动向客户端推送数据的功能。</li><li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。</li></ul><p><strong>使用浏览器进行全双工通信的WebSocket</strong></p><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及 API。</p><p><strong>WebSocket 协议</strong></p><p>主要特点：</p><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能。</li><li>减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。</li></ul><p><strong>期盼已久的 HTTP/2.0</strong></p><p>特点：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819163846.png" alt></p><p><strong>Web 服务器管理文件的 WebDAV</strong></p><p>WebDAV（基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。</p><h2 id="第十章、构建-Web-内容的技术"><a href="#第十章、构建-Web-内容的技术" class="headerlink" title="第十章、构建 Web 内容的技术"></a>第十章、构建 Web 内容的技术</h2><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>动态 HTML</li><li>CGI</li><li>Servlet</li><li>XML</li><li>RSS/Atom</li><li>JSON</li></ul><h2 id="第十一章、Web-的攻击技术"><a href="#第十一章、Web-的攻击技术" class="headerlink" title="第十一章、Web 的攻击技术"></a>第十一章、Web 的攻击技术</h2><p>对 Web 应用的攻击模式有以下两种：</p><ul><li>主动攻击：是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式</li><li>被动攻击：指利用圈套策略执行攻击代码的攻击模式</li></ul><p><strong>因输出值转义不完全引发的安全漏洞：</strong></p><ul><li>XSS 注入</li><li>SQL 注入</li><li>OS 命令注入</li><li>HTTP 首部注入攻击</li><li>邮件首部注入攻击</li><li>目录遍历攻击</li><li><p>远程文件包含漏洞</p><p><strong>因设置或设计上的缺陷引发的安全漏洞：</strong></p></li><li><p>强制浏览</p></li><li>不正确的错误信息处理</li><li>开放重定向</li></ul><p><strong>因会话管理疏忽引发的安全漏洞：</strong></p><ul><li>会话劫持</li><li>会话固定攻击</li><li>跨站点请求伪造</li></ul><p><strong>其他安全漏洞：</strong></p><ul><li>密码破解</li><li>点击劫持</li><li>DoS 攻击</li><li>后门程序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;本书对互联网基盘——HTTP协议进行了全面系统的介绍。作者由HTTP协议的发展历史娓娓道来，严谨细致地剖析了HTTP协议的结构，列举诸多常见通信场景及实战案例，最后延伸到Web安全、最新技术动向等方面。本书的特色为在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解HTTP通信过程中客户端与服务器之间的交互情况。读者可通过本书快速了解并掌握HTTP协议的基础，前端工程师分析抓包数据，后端工程师实现REST API、实现自己的HTTP服务器等过程中所需的HTTP相关知识点本书均有介绍。&lt;br&gt;&lt;br&gt;本书适合Web开发工程师，以及对HTTP协议感兴趣的各层次读者。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="读书" scheme="https://4ark.me/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://4ark.me/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>PhpStorm 使用 PHPCS 检查代码规范及自动修正和Git提交检查</title>
    <link href="https://4ark.me/post/6959bf0.html"/>
    <id>https://4ark.me/post/6959bf0.html</id>
    <published>2019-07-26T16:20:15.000Z</published>
    <updated>2020-06-13T09:36:01.375Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>在团队开发中，每个人的代码风格都不一样，为了日后方便更新和维护，必须考虑协作和编码规范。<br>本文就介绍如何在 PhpStorm 中配置 PSR2 代码规范检查和保存自动格式化修复，以及利用 Git Hook 对提交的代码进行检查。<br></div><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><div class="excerpt"><br>在团队开发中，每个人的代码风格都不一样，为了日后方便更新和维护，必须考虑协作和编码规范。</div></p><p>本文就介绍如何在 PhpStorm 中配置 PSR2 代码规范检查和保存自动格式化修复，以及利用 Git Hook 对提交的代码进行检查。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="安装PHP-CS"><a href="#安装PHP-CS" class="headerlink" title="安装PHP-CS"></a>安装PHP-CS</h3><pre><code>composer global require &quot;squizlabs/php_codesniffer=*&quot;</code></pre><p>安装完成后会在全局依赖包目录生成 phpcbf 和 phpcs 文件</p><blockquote><p>查看 composer 全局依赖包路径，下面会用到</p></blockquote><pre><code>composer global config bin-dir --absolute</code></pre><h3 id="配置-PhpStorm-使用-PSR-2-标准"><a href="#配置-PhpStorm-使用-PSR-2-标准" class="headerlink" title="配置 PhpStorm 使用 PSR-2 标准"></a>配置 PhpStorm 使用 PSR-2 标准</h3><h4 id="1-代码风格"><a href="#1-代码风格" class="headerlink" title="1. 代码风格"></a>1. 代码风格</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/d8bf4d6423310685be6a4bdcd55ff64.png" alt="img"></p><h4 id="2-设置-PHP-CS-路径"><a href="#2-设置-PHP-CS-路径" class="headerlink" title="2. 设置 PHP-CS 路径"></a>2. 设置 PHP-CS 路径</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/150de5624de5b230c93bb636eb794e7.png" alt="img"></p><h4 id="3-代码检查"><a href="#3-代码检查" class="headerlink" title="3. 代码检查"></a>3. 代码检查</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/3eb78dc76568e3656798747eea83e8c.png" alt="img"></p><blockquote><p>如果没有下拉选项，可以点击旁边的刷新按钮</p></blockquote><p>还有这个</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/d9c37df038c2cf0a6538ea4bc5630ca.png" alt="img"></p><p>配置到这里后，打开一个 PHP 文件，就会在不符合 PSR-2 的代码下边加一条波浪线</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727141029.png" alt="img"></p><p>使用 <code>Ctrl + Alt + L</code> 将会自动格式化成 PSR-2 的风格</p><h3 id="集成-PHP-CS"><a href="#集成-PHP-CS" class="headerlink" title="集成 PHP-CS"></a>集成 PHP-CS</h3><p>经过上面的操作，Phpstorm 代码格式化的规则基本与 PHP-CS 的规则基本一致了，但也有一小部分不一致，所以后面还要用到 phpcs 和 phpcbf</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727141709.png" alt="img"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727141817.png" alt="img"></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>Program：<code>phpcs/phpcbf</code> 路径</p><p>Arguments：</p><pre><code>--standard=PSR2 $FileDir$/$FileName$ ## 当前文件--standard=PSR2 $FileDir$ ## 当前文件夹</code></pre><p>Working directory：<code>$ProjectFileDir$</code></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727142731.png" alt="img"></p><h3 id="配置保存自动格式化和修复"><a href="#配置保存自动格式化和修复" class="headerlink" title="配置保存自动格式化和修复"></a>配置保存自动格式化和修复</h3><h5 id="1-为-phpcbf-添加快捷键"><a href="#1-为-phpcbf-添加快捷键" class="headerlink" title="1. 为 phpcbf 添加快捷键"></a>1. 为 phpcbf 添加快捷键</h5><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727142957.png" alt="img"></p><h5 id="2-录制宏"><a href="#2-录制宏" class="headerlink" title="2. 录制宏"></a>2. 录制宏</h5><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727143052.png" alt="img"></p><p>步骤：</p><ol><li><code>Ctrl + Alt + L</code></li><li><code>Ctrl + Alt + Shift + P</code> （phpcbf 快捷键）</li><li><code>Ctrl + S</code></li><li>按下编辑器右下角保存录制</li></ol><h5 id="3-为宏配置快捷键"><a href="#3-为宏配置快捷键" class="headerlink" title="3. 为宏配置快捷键"></a>3. 为宏配置快捷键</h5><p>先删除默认的保存快捷键 <code>Ctrl + S</code>，另外配置一个别的快捷键<code>Ctrl + Alt + Shift + S</code></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727143522.png" alt="img"></p><p>为宏配置快捷键</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727143824.png" alt="img"></p><h3 id="利用-Git-Hook-对提交的代码进行检查"><a href="#利用-Git-Hook-对提交的代码进行检查" class="headerlink" title="利用 Git Hook 对提交的代码进行检查"></a>利用 Git Hook 对提交的代码进行检查</h3><h4 id="安装-GrumPHP"><a href="#安装-GrumPHP" class="headerlink" title="安装 GrumPHP"></a>安装 GrumPHP</h4><pre><code>composer require --dev phpro/grumphp</code></pre><p>安装完后会自动生成一个 <code>grumphp.yml</code></p><p>请修改成：</p><pre><code>parameters:  git_dir: .  bin_dir: vendor/bin  tasks:    phpcs:      standard: PSR2      ignore_patterns:        - ./database/*        - ./vendor/*</code></pre><p>这样 <code>git commit</code> 的时候就会对提交的代码进行检查，只有符合 PSR-2 规范的代码才能通过。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;在团队开发中，每个人的代码风格都不一样，为了日后方便更新和维护，必须考虑协作和编码规范。&lt;br&gt;本文就介绍如何在 PhpStorm 中配置 PSR2 代码规范检查和保存自动格式化修复，以及利用 Git Hook 对提交的代码进行检查。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="团队开发" scheme="https://4ark.me/categories/%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="后端" scheme="https://4ark.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="团队开发" scheme="https://4ark.me/tags/%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《黑客与画家》-读书笔记</title>
    <link href="https://4ark.me/post/d94be22b.html"/>
    <id>https://4ark.me/post/d94be22b.html</id>
    <published>2019-05-19T12:37:23.000Z</published>
    <updated>2020-06-13T09:36:01.376Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>本书是硅谷创业之父Paul Graham 的博客文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。<br></div><a id="more"></a><blockquote><p>本书是硅谷创业之父 Paul Graham 的博客文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。</p><p>本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近读完这本书，写得很不错，适合边读边思考，作者从自身经历讨论了很多问题，包括书呆子、政治、财富、创业、编程语言、设计等问题。</p><p>另外本人看的是阮一峰翻译的版本，文笔非常流畅，一点都没有翻译的腔调，感觉是直接用母语写出一般。</p><p>在此感谢作者 Paul Graham 先生和 译者阮一峰先生。</p><p>声明，这本书的每章都是相互独立的，不必要按顺序阅读。</p><p>全书大致分为 3 部分</p><ul><li>1-4 章解释黑客如何成长以及如何看待世界</li><li>5-9 章介绍创业、工作的方法论</li><li>10-15 章讨论编程语言的特点和使用方法</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1、为什么书呆子不受欢迎"><a href="#1、为什么书呆子不受欢迎" class="headerlink" title="1、为什么书呆子不受欢迎"></a>1、为什么书呆子不受欢迎</h3><p>黑客的特点之一便是高智商，在学校一般表现为书呆子形象，不受欢迎，其主要原因是，他们专注于解决自己感兴趣的事情，而不想花心思去取悦别人。但是学校不是社会，这里并不需要解决问题的人，于是书呆子们完全没有用武之地。但是，一旦这些书呆子走入社会，社会需要能够真正解决问题的人，于是书呆子们的价值就体现出来了。</p><h3 id="2、黑客与画家"><a href="#2、黑客与画家" class="headerlink" title="2、黑客与画家"></a>2、黑客与画家</h3><p>与作曲家、建筑师、作家一样，黑客和画家都是试图创作出优秀作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）。</p><p>从这个基本观点出发，通过借鉴这些创作领域的创作模式，我们可以得出一些重要的启示：</p><ol><li>编程不应该是先将思路完全想好，然后去写代码。思路的完善应该是在代码编写过程中完成的。好的编程语言应是允许动态扩展的语言，编程语言是帮助我们思考的，而 不仅仅是表达已经想好的想法。</li><li>学习编程，应是实践的过程。在敲代码，写程序中去学习。</li><li>保留自己写过的代码，时常翻看。</li><li>大量阅读范例程序，充分利用开源的资源。</li></ol><p>作者也提到在大公司中，并不能发挥一个黑客的所有能力，如果你想开发出的优秀软件，那么可以选择创业，但是这样会导致你必须处理许多与开发软件无关的事情，并且赚钱的软件往往不是好玩的软件，所以解决方法是：找一个养家糊口的”白天工作“，然后在其余时间开发优美的软件。</p><h3 id="3、不能说的话"><a href="#3、不能说的话" class="headerlink" title="3、不能说的话"></a>3、不能说的话</h3><p>先问自己：你是一个随大流的人吗？有没有什么观点不愿说出口？你的观点是别人灌输给你的，还是独立思考得到的？</p><p>不管哪个年代，有一件事都是不会改变的，那就是“祸从口出”。</p><p>满足“不能说的话”的两个条件 ：</p><ol><li>这些话不能说出口</li><li>它们是正确的，或者看起来很可能正确，值得进一步讨论</li></ol><p>其中第二条更重要，很显然，你说一句 5+3=53 并不会引起人们的注意，除了嘲笑和鄙视。因为怒触他人的言论是那些可能会有人相信的言论。我猜想，最令人暴跳如雷的言论，就是被认为说出了真相的言论。</p><p>明确了什么是“不能说的话”，接着，作者给出了五种找出“不能说的话”的方法：</p><ol><li><p>判断言论的真伪</p></li><li><p>关注“异端邪说”</p><blockquote><p>历史上的每一个年代，都会给”异端邪说“贴一些标签，目的是在人们开始思考它们是否为真之前就把它们封杀。其实在当代，也有这样的问题。我们应该多加注意那些贴标签的行为。</p></blockquote></li><li><p>将当代观念与不同时期的古代观念 diff 一下，将当代不同地方的观念 diff 一下</p></li><li><p>寻找那些一本正经的卫道者，看看他们到底在捍卫着什么。作者用一个例子解释，父母在家里会尽量避免说脏话，只是不想让孩子学到。但是，孩子虽然没从父母那里学会说脏话，但是从他的朋友那里学到了。所以在家里，父母和孩子都不说脏话，而在外面都尽情地说。</p></li><li><p>观察禁忌是如何产生的。流行的道德观念往往不是偶然产生的，而是被刻意创造出来的。如果有些观点不能说，可能的原因是某些团体不让我们说。</p><blockquote><p>我猜想，道德禁忌的最大制造者是那些权力斗争中略占上风的一方。你会发现，这一方有实力推行禁忌，同时又软弱到需要禁忌保护自己的利益。</p></blockquote></li></ol><h3 id="4、良好的坏习惯"><a href="#4、良好的坏习惯" class="headerlink" title="4、良好的坏习惯"></a>4、良好的坏习惯</h3><p>黑客往往是不服从管教的，并以违反常理的思维方式思考、行动。虽然他们的行为常常导致平凡大众的反感，甚至厌恶，进而产生了偏见，但是这种“坏习惯”反而利大于弊，让他们保持了一种常人不具备的敏感，尤其是对于一些貌似无关痛痒，却与所有人息息相关的政治行为。</p><p>举例来说，为什么程序员会比其他人更在乎公民自由？表面上来看，政府侵犯公民自由并不会让代码质量下降，而只是逐渐导致一个观点占据上风。而如果一旦极权主义制度形成，那么这种制度就很难废除。黑客对公民自由这一概念比普通人理解的更透彻，更重要的是，他们明白失去知识自由之后未来的样子。所以他们能感知即将到来的暴风雨。</p><p>那些占据高位、本能地想要约束黑客、强迫黑客服从的人们，请小心你们的要求，因为你们真有可能成为千古罪人。</p><h3 id="5、另一条路"><a href="#5、另一条路" class="headerlink" title="5、另一条路"></a>5、另一条路</h3><p>在作者看来，一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。</p><p>要让软件变得可靠，关键是你要全神贯注，而不是开发得很慢。</p><p>如果你亲眼见到某人第一次使用你的软件，你就会知道软件的哪个地方最打动他。</p><p>互联网做起来很辛苦，还有许多特别大的压力，但是它们的唯一作用，就是使得创业公司成功的机会变大。</p><p>管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。只要做到这两点，你就会超过大多数创业公司。</p><p>另外，如果你不打算自己动手开发和设计，那就不要创业。</p><h3 id="6、如何创造财富"><a href="#6、如何创造财富" class="headerlink" title="6、如何创造财富"></a>6、如何创造财富</h3><p>金钱不等于财富，创造有价值的东西就是创造财富。你最好先搞清楚什么是财富。财富与金钱并不是同义词。财富存在的时间与人类历史一样长久，甚至更长久，事实上蚂蚁也拥有财富。金钱是一种历史相对较短的发明。</p><p>要致富，你需要两样东西：可测量性和可放大性。</p><p>如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险，就几乎等于没有可放大性。</p><p>创业公司通过发明新技术盈利，所以具备可放大性。</p><p>如果你开发出来的技术是竞争对手难于复制的，那就够了，你不需要依靠其他防御手段了。</p><p>不应该收购的危险信号，排在榜首的信号中有一个就是公司由技术顽童掌控，只想解决有趣的技术问题，不考虑用户的需要。你开办创业公司不是单纯地为了解决问题，而是为了解决那些用户关心的问题。</p><p>政府禁止个人积累财富实际上就是命令人民减慢工作的速度。</p><p>只要懂得藏富于民，国家就会变得强大。</p><h3 id="7、关注贫富分化"><a href="#7、关注贫富分化" class="headerlink" title="7、关注贫富分化"></a>7、关注贫富分化</h3><p>进入社会以后，你不能总是靠父母养活，如果你需要什么东西，要么你自己做出来，要么做其他东西与需要的人交换金钱，再用金钱去买你想要的东西</p><p>技术肯定加剧了有技术者与无技术者之间的生产效率差异</p><p>技术在加大收入差距的同时，缩小了大部分的其他差距</p><h3 id="8、防止垃圾邮件的一个方法"><a href="#8、防止垃圾邮件的一个方法" class="headerlink" title="8、防止垃圾邮件的一个方法"></a>8、防止垃圾邮件的一个方法</h3><p>这一节对于现在这个年代的意义不是很大，作者认为过滤垃圾邮件是可以做到的，基于内容的过滤器将发挥作用。 但是在他那个年代，意义很大的。</p><p>要对单个词语进行贝叶斯判断，就能很好地过滤大部分垃圾邮件。后面通过统计学的方法做了一个过滤器，其实有点像现在的机器学习了。</p><h3 id="9、设计者的品味"><a href="#9、设计者的品味" class="headerlink" title="9、设计者的品味"></a>9、设计者的品味</h3><p>他想要的学生不仅应该技术过硬，还应当能够使用技术做出优美的产品</p><p>你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。解决难题的痛苦对设计师有好处，但是对付挑剔的客户的痛苦或者对付质量低劣的建材的痛苦就是另外一回事了</p><p>在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出伟大的成绩。如果你远离这些中心，几乎不可能单靠自己就取得伟大成果</p><h3 id="10、编程语言解析"><a href="#10、编程语言解析" class="headerlink" title="10、编程语言解析"></a>10、编程语言解析</h3><p>程序员的时间比计算机的时间昂贵得多。</p><p>长期使用某种语言，就会慢慢按照这种语言的思维模式进行思考。</p><p>静态类型语言与动态类型语言没有绝对的好坏之分，每个人都可以有自己的选择。</p><h3 id="11、一百年后的编程语言"><a href="#11、一百年后的编程语言" class="headerlink" title="11、一百年后的编程语言"></a>11、一百年后的编程语言</h3><p>语言只是一种书写法，程序则是一种严格符合规则的描述，以书面形式记录计算机如何解决你的问题。<br>随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。<br>浪费分成好的浪费和坏的浪费，感兴趣的就是好的浪费，即用更多的钱得到更简单的设计。<br>对速度的追求是人类内心根深蒂固的欲望，设计编程语言的时候，应该有意识地问问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。<br>将语言的语义与语言的实现分离。<br>写文章，就是为了试着搞清楚某件事情，对于软件而言也是如此。<br>效率低下的软件并不等于很烂的软件，一种让程序员做无用功的语言才真正称得上很烂，浪费程序员的时间而不是浪费机器的时间才是真正的无效率。<br>面向对象编程，使得可以对代码进行可持续性开发。<br>性能分析器有助于指导程序开发，现在许多人仍然相信程序运行速度提升的关键在于开发出能够生成更快速代码的编译器。</p><ul><li>一百年后的编程语言在理论上今天就能设计出来。</li><li>如果今天真的能设计出这样一种语言，很可能现在适合编程，并且能够产生更好的结果。</li></ul><h3 id="12、拒绝平庸"><a href="#12、拒绝平庸" class="headerlink" title="12、拒绝平庸"></a>12、拒绝平庸</h3><p>这一节作者在推广 Lisp 语言，Lisp 很值得学习，你掌握它以后，会感到它给你带来的极大启发，这会大大提高你的编程水平，使你成为一个更好的程序员，尽管在实际工作中极少会用到 Lisp。</p><h3 id="13、书呆子的复仇"><a href="#13、书呆子的复仇" class="headerlink" title="13、书呆子的复仇"></a>13、书呆子的复仇</h3><p>在某些情况下，一些语言就是比另一些语言更出色。<br>认为所有语言都一样的看法的缺点是自欺欺人，但优点是可以使许多事情变得很简单。<br>编程语言现在的发展不过刚刚赶上 1958 年 Lisp 语言的水平。</p><p>为什么 Lisp 很特别，因为 Lisp 刚诞生的时候包含的 9 种思想：</p><ol><li>条件结构(即 if-else 结构)</li><li>函数也是一种数据结构</li><li>递归</li><li>变量的动态类型</li><li>垃圾回收机制</li><li>程序由表达式组成</li><li>符号类型</li><li>代码使用符号和常量组成的树形表示法</li><li>无论什么时候，整个语言都是可用的（Lisp 不真正区分读取期、编译期、运行期）</li></ol><h3 id="14-梦寐以求的编程语言"><a href="#14-梦寐以求的编程语言" class="headerlink" title="14.梦寐以求的编程语言"></a>14.梦寐以求的编程语言</h3><p>这种语言干净简练，具有最高层次的抽象和互动性，而且很容易装备，可以只用很少的代码就解决常见的问题。不管是什么程序，你真正要写的代码几乎都与你自己的特定设置有关，其他具有普遍性的问题都有现成的函数库可以调用。</p><p>这种语言有大量优秀的范例可供学习，而且非常符合直觉，你只需花几分钟阅读范例就能领会应该如何使用此种语言。</p><p>这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层之上。如果需要的话，你可以直接使用较低的抽象层。</p><p>这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你的开发，而不是为了强迫你按照它的方式行事。</p><h3 id="15、设计与研究"><a href="#15、设计与研究" class="headerlink" title="15、设计与研究"></a>15、设计与研究</h3><p>让用户满意并不等于迎合用户的一切要求，用户不了解所有可能的选择，也经常弄错自己真正想要的东西。<br>编程语言也应该是以人为本。<br>贴近用户的设计思想被归纳为“弱即是强”模式。<br>任何时候，代码都必须能够运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;本书是硅谷创业之父Paul Graham 的博客文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="读书" scheme="https://4ark.me/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://4ark.me/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解按位操作符</title>
    <link href="https://4ark.me/post/3953655a.html"/>
    <id>https://4ark.me/post/3953655a.html</id>
    <published>2019-03-15T06:57:43.000Z</published>
    <updated>2020-06-13T09:36:01.378Z</updated>
    
    <content type="html"><![CDATA[<p>按位操作符（Bitwise operators） 的计算主要用在二进制中，虽然平时很少有机会用到按位操作符，但不得不承认，在某些时候，这些操作符能够给我们提供很好的解决方案。</p><a id="more"></a><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>按位操作符（Bitwise operators） 的计算主要用在二进制中，虽然平时很少有机会用到按位操作符，但不得不承认，在某些时候，这些操作符能够给我们提供很好的解决方案。</p><p>下面介绍操作符时，也会提供一些比较经典的例子，来看看它们是如何巧妙地解决问题的吧。</p><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><h3 id="2-1-二进制"><a href="#2-1-二进制" class="headerlink" title="2.1 二进制"></a>2.1 二进制</h3><blockquote><p>本文假设你知道计算机中用二进制数来存储，计算数字，并且熟悉二进制数的表示方法。</p></blockquote><p>讲解位操作符之前，先简单讲一下真值、原码、反码和补码。</p><h4 id="2-1-1-真值"><a href="#2-1-1-真值" class="headerlink" title="2.1.1 真值"></a>2.1.1 真值</h4><p>我们表示自然数包括正数，负数和0，下面是1和-1的二进制表示：</p><pre><code>+ 00000001 # +1- 00000001 # -1</code></pre><h4 id="2-1-2-原码"><a href="#2-1-2-原码" class="headerlink" title="2.1.2 原码"></a>2.1.2 原码</h4><p>但是计算机只能存储0和1，不能存储正负，所以一个数的最高位存放符号，正数为0，负数为1，用后面七位来表示真值的绝对值：</p><pre><code>0 0000001 # +11 0000001 # -1</code></pre><p>由于<code>10000000</code>表示为 -0 ,这个没有意义，所以这个数字被用来表示 -128，所以负数就比整数多一个。</p><h4 id="2-1-3-反码"><a href="#2-1-3-反码" class="headerlink" title="2.1.3 反码"></a>2.1.3 反码</h4><p>反码的表示方法是：正数不变，负数是在其原码的基础上，符号位不变，其余位取反：</p><pre><code>0 0000001 # +11 1111110 # -1</code></pre><h4 id="2-1-4-补码"><a href="#2-1-4-补码" class="headerlink" title="2.1.4 补码"></a>2.1.4 补码</h4><p>补码的作用主要是为了简化运算，将减法变为加法而发明的数学表示法，其表示方法是：正数不变，负数是在其反码的基础上+1：</p><pre><code>0 0000001 # +11 1111111 # -1</code></pre><h4 id="2-1-5-最后"><a href="#2-1-5-最后" class="headerlink" title="2.1.5 最后"></a>2.1.5 最后</h4><pre><code>[+1] = [0000 0001]原      = [0000 0001]反     = [0000 0001]补--------------------[-1] = [1000 0001]原     = [1111 1110]反     = [1111 1111]补</code></pre><h3 id="2-2-按位逻辑操作符"><a href="#2-2-按位逻辑操作符" class="headerlink" title="2.2. 按位逻辑操作符"></a>2.2. 按位逻辑操作符</h3><p>从概念上讲，按位逻辑操作符遵循下面规则：</p><ul><li><p>操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。</p></li><li><p>第一个操作数的每个比特位与第二个操作数的相应比特位匹配：第一位对应第一位，第二位对应第二位，以此类推。</p></li><li>位运算符应用到每对比特位，结果是新的比特值。</li></ul><p>下面开始讲解各种位操作符。</p><p>注意：</p><blockquote><p>前面提到操作会被转换成32位整数，但为了简化，将使用8位整数来演示运算过程。</p></blockquote><h4 id="2-2-1-AND（与）"><a href="#2-2-1-AND（与）" class="headerlink" title="2.2.1 AND（与）"></a>2.2.1 AND（与）</h4><p>对每一对比特位执行与（AND）操作。只有 a 和 b 都是 1 时，a AND b 才是 1。与操作的真值表如下：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">a AND b</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><p>下面展示<code>11 &amp; 14</code>的运算过程：</p><pre><code>11 = 0000 101114 = 0000 1110     0000 1010 = 10</code></pre><p>注意：</p><ul><li>任何数和 0 进行 AND 都为0：<code>x &amp; 0 = 0</code>。</li><li>任何数和 -1 进行 AND 都为自身：<code>x &amp; -1 = x</code>。</li></ul><p>例子1（判断一个数的奇偶）：</p><pre><code class="javascript">// n &amp; 1 === 0console.log( 2 &amp; 1 ) // 0console.log( 3 &amp; 1 ) // 1/*原因：所有偶数的最低位都是0，所有奇数的最低位都是1。实例1：    16 = 10000    1 =  00001         00000 = 0    实例2：    15 = 1111    1 =  0001         0001 = 1             */</code></pre><p>例子2（判断一个数是否为2的整数幂）：</p><pre><code class="javascript">// n &amp; (n-1) === 0console.log( 4 &amp; ( 4 - 1 ) ) // 0console.log( 5 &amp; ( 5 - 1 ) ) // 4/*原因：如果是2的幂，n 一定是 100...，而 n-1 一定是 111...实例1：    16 = 10000    15 = 01111         00000 = 0    实例1：    15 = 1111    14 = 1110         1110 = 14             */</code></pre><h4 id="2-2-2-OR（或）"><a href="#2-2-2-OR（或）" class="headerlink" title="2.2.2 OR（或）"></a>2.2.2 OR（或）</h4><p>对每一对比特位执行或（OR）操作。只有 a 或者 b 中至少有一位是 1 时， <code>a</code> OR <code>b</code> 才为 1。或操作的真值表：</p><table><thead><tr><th>a</th><th>b</th><th>a OR b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>下面展示<code>11 | 14</code>的运算过程：</p><pre><code>11 = 0000 101114 = 0000 1110     0000 1111 = 15</code></pre><p>注意：</p><ul><li>任何数和 0 进行 OR 都为自身：<code>x | 0 = x</code>。</li><li>任何数和 -1 进行 OR 都为 -1：<code>x | -1 = -1</code>。</li></ul><h4 id="2-2-3-XOR（异或）"><a href="#2-2-3-XOR（异或）" class="headerlink" title="2.2.3 XOR（异或）"></a>2.2.3 XOR（异或）</h4><p>对每一对比特位执行异或（XOR）操作。当 a 和 b 不相同时，<code>a</code> XOR <code>b</code> 的结果为 1。异或操作真值表：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">a XOR b</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>下面展示<code>11 ^ 14</code>的运算过程：</p><pre><code>11 = 0000 101114 = 0000 1110     0000 0101 = 5</code></pre><p>注意：</p><ul><li>任何数和 0 进行 XOR 都为自身：<code>x ^ 0 = x</code>。</li><li>任何数和 -1 进行 OR 都为 ~x：<code>x | -1 = ~x</code>。</li></ul><p>例子1（不用临时变量交换两个数）：</p><pre><code class="javascript">var a = 10, b = 20a ^= bb ^= aa ^= bconsole.log(a,b) // 20,10/*原因（公式）：    20 ^ 10 = 30 # c = a ^ b    30 ^ 20 = 10 # b = c ^ a    30 ^ 10 = 20 # a = c ^ b实例：    a = 01010    b = 10100    c = 11110 # a ^ b的结果，其中的1是 a 和 b 中不同的部分     d = 01010 # b ^ c的结果，有没有发现和a是一样的    e = 10100 # c ^ d的结果，有没有发现是b是一样的    a = a ^ b # 得到c 11110    b = b ^ a # 得到d 01010    a = a ^ b # 得到e 10100*/</code></pre><p>例子2（找到数组中出现奇数次的元素）：</p><pre><code class="javascript">// 一个非空数组，只有一个元素出现奇数次，其余出现偶数次，找出那个元素:var arr = [1,1,2,3,3]var res = 0for (var i=0; i&lt;arr.length; i++){    res ^= arr[i]}console.log(res) // 2/*   任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，   那么最终的结果刚好是那个只出现奇数次的数字，因为那些出现偶数次的数字全部在异或中抵消掉了。*/</code></pre><h4 id="2-2-4-NOT（非）"><a href="#2-2-4-NOT（非）" class="headerlink" title="2.2.4 NOT（非）"></a>2.2.4 NOT（非）</h4><p>对每一个比特位执行非（NOT）操作。NOT <code>a</code> 结果为 a 的反转（即反码）。非操作的真值表：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">NOT a</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>下面展示<code>~11</code>的运算过程：</p><pre><code>11 = [0000 1011‬]原   = [0000 1011‬]反   = [‭0000 1011]补 # 将操作数转成补码 -----------------------------     [‭0000 1011]补   = [1111 0100]补 # 然后按位取反 -----------------------------     [1111 0100]补    = [1111 0011]反   = [1000 1100]原 # 转成原码   = -12</code></pre><p>接着展示<code>~-11</code>的运算过程：</p><pre><code>-11 = [1000 1011‬]原    = [1111 0100‬]反    = [‭1111 0101]补 # 将操作数转成补码 -----------------------------      [‭1111 0101]补    = [0000 1010]补 # 然后按位取反 -----------------------------      [0000 1010]补     = [0000 1010]反    = [0000 1010]原 # 转成原码    = 10</code></pre><p>注意：</p><ul><li>对任何数 x 进行 NOT 操作的结果为 -(x + 1)，<code>~x = -(x+1)</code>。</li></ul><h3 id="2-3-按位移动操作符"><a href="#2-3-按位移动操作符" class="headerlink" title="2.3 按位移动操作符"></a>2.3 按位移动操作符</h3><p>按位移动操作符有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。移动的方向根据操作符的不同而不同。</p><p>按位移动会先将操作数转换为高位字节顺序的32位整数，并返回与左操作符相同的类型。右操作数小于32位，否则只有最低5个字节会被使用。</p><h4 id="2-3-1-lt-lt-（左移）"><a href="#2-3-1-lt-lt-（左移）" class="headerlink" title="2.3.1 &lt;&lt;（左移）"></a>2.3.1 &lt;&lt;（左移）</h4><p>该操作数会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用0补充。</p><p>下面展示<code>11&lt;&lt;2</code>的运算过程：</p><pre><code>11 = [0000 1011]原   = [0000 1011]反   = [0000 1011]补---------------------------------         0000 1011   00 0010 1100 # 向左移2位，用0补充      1101 0100 # 被移出的位被丢弃---------------------------------           [1101 0100]补   = [1101 0011]反   = [1010 1100]原 # 转成原码   = -44</code></pre><p>接着是<code>-11&lt;&lt;2</code>的运算过程：</p><pre><code>11 = [1000 1011]原   = [1111 0100]反   = [1111 0101]补---------------------------------         1111 0101   11 1101 0100 # 向左移2位，用0补充      1101 0100 # 被移出的位被丢弃---------------------------------           [1101 0100]补   = [1101 0011]反   = [1010 1100]原 # 转成原码   = -44</code></pre><p>注意：</p><ul><li>在数字 x 上左移 y 位得到 x * 2y：<code>x &lt;&lt; y === x * pow(2,y)</code>。</li></ul><p>例子：</p><pre><code class="javascript">// 1.获得 int 型最大值console.log(  ~(1 &lt;&lt; 31) ) // 2147483647// 2.获得 int 型最小值console.log( 1 &lt;&lt; 31 ) // -2147483648// 3.乘以2的m次方console.log( 1 &lt;&lt; 10, 1 * Math.pow(2,10) ) // 1024,1024</code></pre><h4 id="2-3-2-gt-gt-（有符号右移）"><a href="#2-3-2-gt-gt-（有符号右移）" class="headerlink" title="2.3.2 &gt;&gt;（有符号右移）"></a>2.3.2 &gt;&gt;（有符号右移）</h4><p>该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。</p><p>下面展示<code>11&gt;&gt;2</code>的运算过程：</p><pre><code>11 = [0000 1011]原   = [0000 1011]反   = [0000 1011]补---------------------------------         0000 1011      0000 0010 11 # 向右移2位，填充最左侧的值      0000 0010 # 被移出的位被丢弃---------------------------------           [0000 0010]补   = [0000 0010]反   = [0000 0010]原 # 转成原码   = 2</code></pre><p>接着是<code>-11&gt;&gt;2</code>的运算过程：</p><pre><code>11 = [1000 1011]原   = [1111 0100]反   = [1111 0101]补---------------------------------         1111 0101      1111 1101 01 # 向右移2位，填充最左侧的值      1111 1101 # 被移出的位被丢弃---------------------------------           [1111 1101]补   = [1111 1100]反   = [1000 0011]原 # 转成原码   = -3</code></pre><p>例子：</p><pre><code class="javascript">// 1.求两个整数的平均值（结果有小数点时抛弃小数点）console.log(  （1 + 4） &gt;&gt; 1 ) // 2// 2.除以2的m次方console.log( 1 &gt;&gt; 10, 1 * Math.pow(2,10) ) // 1024,1024</code></pre><h4 id="2-3-3-gt-gt-gt-（无符号右移）"><a href="#2-3-3-gt-gt-gt-（无符号右移）" class="headerlink" title="2.3.3 &gt;&gt;&gt;（无符号右移）"></a>2.3.3 &gt;&gt;&gt;（无符号右移）</h4><p>该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）</p><p>对于非负数，有符号右移和无符号右移总是返回相同的结果。例如：<code>11 &gt;&gt; 2 === 11 &gt;&gt;&gt; 2</code>。</p><p>而对于负数却不尽相同，下面展示<code>-11&gt;&gt;&gt;2</code>的运算过程（这里需要用到的位数较多，所以用32位整数演示）：</p><pre><code>-11 = [‭1000 0000 0000 0000 0000 0000 0000 1011]原    = [‭1111 1111 1111 1111 1111 1111 1111 0100]反    = [‭1111 1111 1111 1111 1111 1111 1111 0101]补-----------------------------------------------------       ‭1111 1111 1111 1111 1111 1111 1111 0101       0011 1111 1111 1111 1111 1111 1111 1101 01 # 向右移2位，左侧填充0       0011 1111 1111 1111 1111 1111 1111 1101 # 被移出的位被丢弃-----------------------------------------------------      [0011 1111 1111 1111 1111 1111 1111 1101]补    = [0011 1111 1111 1111 1111 1111 1111 1101]补    = [0011 1111 1111 1111 1111 1111 1111 1101]原 # 转成原码    = 1073741821   </code></pre><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ul><li><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></li><li><a href="https://blog.csdn.net/oscar999/article/details/8928789" target="_blank" rel="noopener">真值，原码，反码，补码和移码 释义</a></li><li><a href="https://yanhaijing.com/javascript/2016/07/20/binary-in-js/" target="_blank" rel="noopener">聊聊JavaScript中的二进制数</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">按位操作符 MDN</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/6275483.html" target="_blank" rel="noopener">JS按位非(~)运算符与~~运算符的理解分析</a></li><li><a href="https://blog.csdn.net/zmazon/article/details/8262185" target="_blank" rel="noopener">优秀程序员不得不知道的20个位运算技巧</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按位操作符（Bitwise operators） 的计算主要用在二进制中，虽然平时很少有机会用到按位操作符，但不得不承认，在某些时候，这些操作符能够给我们提供很好的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://4ark.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://4ark.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Window上更方便的软件安装方式 — Chocolatey</title>
    <link href="https://4ark.me/post/8159b49a.html"/>
    <id>https://4ark.me/post/8159b49a.html</id>
    <published>2019-02-23T11:28:07.000Z</published>
    <updated>2020-06-13T09:36:01.375Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    在经历了多次重装系统、重新安装各种常用软件后，我突然萌生了一个想法，难道 Window 就没有一个像 Linux 一样可以使用一行命令安装软件的包管理器吗？<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在经历了多次重装系统、重新安装各种常用软件后，我突然萌生了一个想法，难道 Window 就没有一个像 Linux 一样可以使用一行命令安装软件的包管理器吗？</p><p>答案是：有的。</p><p>我分别使用了 Chocolatey 和 Scoop，得出的结论就是：</p><ol><li>Chocolatey : 软件更多、速度快。</li><li>Scoop：可定制性较强、速度较慢（也有可能是我网络不好）。</li></ol><p>不过这两款包管理器的使用都差不多，这里主要是介绍 Chocolatey，对其他包管理器感兴趣的可以自行查看。</p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>安装 Chocolatey 前，你需要对检查一下自身系统是否达到所需的要求。</p><ul><li>Windows 7+ / Windows Server 2003+</li><li>PowerShell v2+</li><li>.NET Framework 4+</li></ul><p>如果已经满足要求，就可以打开命令行 copy 下面的命令执行。</p><pre><code class="shell">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;(iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))) &gt;$null 2&gt;&amp;1&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</code></pre><p>如果没报红字错误，应该是安装成功了。</p><pre><code class="shell">choco -v# 0.10.11</code></pre><p>接下来你可以打开下方的链接，查看一下可以安装的软件列表。</p><p><a href="https://chocolatey.org/packages" target="_blank" rel="noopener">https://chocolatey.org/packages</a></p><p>比如，安装 Git</p><pre><code class="shell">choco install git</code></pre><p>安装 Node</p><pre><code class="shell">choco install nodejs.install</code></pre><p>也可以加上<code>-y</code>，安装时就不需要等待确认了</p><pre><code class="shell">choco install firefox -y</code></pre><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>安装 <code>choco install baretail</code></li><li>升级 <code>choco upgrade  baretail</code></li><li>卸载 <code>choco uninstall baretail</code></li><li>搜索 <code>choco search something</code></li><li>列出已安装 <code>choco list -lo</code></li></ol><p>关于更多用法可点击以下链接查看：</p><p><a href="https://chocolatey.org/docs" target="_blank" rel="noopener">https://chocolatey.org/docs</a></p><h2 id="修改默认安装目录"><a href="#修改默认安装目录" class="headerlink" title="修改默认安装目录"></a>修改默认安装目录</h2><p>但是，Chocolatey 安装的软件默认存放在 C 盘，对于我这种不太喜欢把软件装到 C 盘的人来说是不能忍的。</p><p>虽然 Chocolatey 自己提供了一个修改默认安装目录的命令，但是需要注册（收费），对于资金充裕的同学我还是建议使用这种方法。</p><p>这里我提供另外一个思路，既然他存到默认安装目录，那我们把这个默认安装目录改一下就好了。</p><p>比如我要默认存放到<code>E</code>盘，打开注册表，把 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion</code> 下的：</p><ol><li><code>ProgramFilesDir</code>的值改为：<code>E:\Program Files</code></li><li><code>ProgramFilesDir (x86)</code>的值改为：<code>E:\Program Files (x86)</code></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢观看！</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    在经历了多次重装系统、重新安装各种常用软件后，我突然萌生了一个想法，难道 Window 就没有一个像 Linux 一样可以使用一行命令安装软件的包管理器吗？&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="系统" scheme="https://4ark.me/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="https://4ark.me/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分享一些好用的 Chrome 扩展</title>
    <link href="https://4ark.me/post/549a6198.html"/>
    <id>https://4ark.me/post/549a6198.html</id>
    <published>2019-02-13T07:22:39.000Z</published>
    <updated>2020-06-13T09:36:01.377Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    使用浏览器扩展程序可以使你的工作效率提高数倍不止，那么下面我就向大家分享一下我日常使用的扩展，可能大多数扩展大家都已经在使用了，不过也难免有一两个是你不知道的。<br>    <img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04uhwp8ozj30hs0b4aal.jpg"><br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用浏览器扩展程序可以使你的工作效率提高数倍不止，那么下面我就向大家分享一下我日常使用的扩展，可能大多数扩展大家都已经在使用了，不过也难免有一两个是你不知道的。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>以下排名并不分先后，请坚持看到最后，或许你会有惊喜。</p></blockquote><h3 id="1-谷歌访问助手"><a href="#1-谷歌访问助手" class="headerlink" title="1.谷歌访问助手"></a>1.谷歌访问助手</h3><p>本来想了一波广告词来吹它，但想到…</p><p>算了，别问，问就是好用。</p><p><strong>注</strong>：装了这个就可以访问之后介绍的扩展链接了。</p><blockquote><p>链接：<a href="http://www.ggfwzs.com/" target="_blank" rel="noopener">谷歌访问助手</a></p></blockquote><h3 id="2-新浪微博图床"><a href="#2-新浪微博图床" class="headerlink" title="2. 新浪微博图床"></a>2. 新浪微博图床</h3><p>感谢新浪微博提供的免费图床（对外链无限制），以及吊炸天的 cdn 图片加速服务，从此妈妈再也不用担心我的图床不能用了，另外还支持在网页图片右键菜单中一键上传。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04uhwp8ozj30hs0b4aal.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf" target="_blank" rel="noopener">新浪微博图床</a></p></blockquote><h3 id="3-AdBlock"><a href="#3-AdBlock" class="headerlink" title="3. AdBlock"></a>3. AdBlock</h3><p>最受欢迎的 Chrome 扩展，拥有超过 6000 万用户！拦截网页上的广告。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04un3rn1fj30hs0b4ac4.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom" target="_blank" rel="noopener">AdBlock</a></p></blockquote><h3 id="4-WEB-前端助手"><a href="#4-WEB-前端助手" class="headerlink" title="4. WEB 前端助手"></a>4. WEB 前端助手</h3><p>前端神器，包括 JSON 格式化、二维码生成与解码、信息编解码、代码压缩、美化、页面取色、Markdown与HTML互转、网页滚动截屏、正则表达式、时间转换工具、编码规范检测、页面性能检测、Ajax接口调试、密码生成器、JSON 比对工具、网页编码设置、便签笔记。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04zik8xc7j31460lm41y.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">WEB前端助手</a></p></blockquote><h3 id="5-JSON-Viewer"><a href="#5-JSON-Viewer" class="headerlink" title="5. JSON Viewer"></a>5. JSON Viewer</h3><p>前面介绍的 WEB 前端工具也有 JSON 查看工具，但是它那个太丑了，所以我用这个，内置多种主题，是我见过最好看的 JSON 查看工具。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04z6k4eubj31460lm76k.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh" target="_blank" rel="noopener">JSON Viewer</a></p></blockquote><h3 id="6-Standardized-Screenshot"><a href="#6-Standardized-Screenshot" class="headerlink" title="6. Standardized Screenshot"></a>6. Standardized Screenshot</h3><p>一个非常好用的截图扩展，自动加上 macOS 的标题栏、以及阴影，配合微博图床一键上传根本不用保存在本地。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04v1q134fj31460lmzlf.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/pabdhaakclnechgfhmnhkcbmjobeoope" target="_blank" rel="noopener">Standardized Screenshot</a></p></blockquote><h3 id="7-Chromoji-Emoji"><a href="#7-Chromoji-Emoji" class="headerlink" title="7. Chromoji - Emoji"></a>7. Chromoji - Emoji</h3><p>在某些系统中并不能显示 Emoji 表情，安装此扩展后就能在浏览器中显示和输入，你也能选择显示 Apple 或 Google 风格的 Emoji。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04x45wnh6j31460lmjvq.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/chromoji-emoji-for-google/cahedbegdkagmcjfolhdlechbkeaieki" target="_blank" rel="noopener">Chromoji - Emoji</a></p></blockquote><h3 id="8-Clear-Cache"><a href="#8-Clear-Cache" class="headerlink" title="8. Clear Cache"></a>8. Clear Cache</h3><p>如果你是前端开发人员，调试时需要经常清空浏览器缓存，以往我们需要经过几个步骤才能完成动作，现在只需单击一下按钮即可清除缓存和浏览数据。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04w1j4tumj31460lmwg3.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/clear-cache/cppjkneekbjaeellbfkmgnhonkkjfpdn" target="_blank" rel="noopener">Clear Cache</a></p></blockquote><h3 id="9-二维码生成器"><a href="#9-二维码生成器" class="headerlink" title="9. 二维码生成器"></a>9. 二维码生成器</h3><p>把当前页面或者你输入的任何内容转化成二维码，生成后的二维码可以保存，并且无需联网，谁用谁知道。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04wsm1d8yj31460lmdhx.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp?hl=zh-CN" target="_blank" rel="noopener">二维码生成器</a></p></blockquote><h3 id="10-翻译侠"><a href="#10-翻译侠" class="headerlink" title="10. 翻译侠"></a>10. 翻译侠</h3><p>这是我用了众多翻译扩展后最喜欢的一个，貌似之前的作者已经不再维护了，现在由网友接手，挺好的，从此不再需要打开谷歌翻译网站。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04xejq3ocj31460lmajm.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/translate-man/fnjoonbenhhijnoegpfkpagjamomgjjm/related?hl=zh-CN" target="_blank" rel="noopener">翻译侠</a></p></blockquote><h3 id="11-图流"><a href="#11-图流" class="headerlink" title="11. 图流"></a>11. 图流</h3><p>这个厉害了，你是否曾为了看图片，一张一张的点，看完一个系列手都费了，简直痛不欲生，现在，福音来了。</p><p>让我们打开知乎问题《<a href="https://www.zhihu.com/question/50426133/answer/243675284" target="_blank" rel="noopener">平常人可以<em>漂亮</em>到什么程度？</a>》，查看全部答案，开启图流，你会发现。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04xrb65foj31460lm7wh.jpg" alt></p><p>另外它还支持轮播展示，如果你经常逛一些你懂得网站，那它简直是老司机神器。</p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/%E5%9B%BE%E6%B5%81-%E7%9C%8B%E5%9B%BE%E5%8A%A9%E6%89%8B/gpcdnjdgomhddecjpknmfodkpkgibajh?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">图流</a></p></blockquote><h3 id="12-阅读模式"><a href="#12-阅读模式" class="headerlink" title="12. 阅读模式"></a>12. 阅读模式</h3><p>提供与Safari阅读模式功能一致的插件，浏览文章页时候可进入友好的阅读模式，并自定义阅读功能。</p><p>唯一美中不足之处就是在阅读模式下无法选中文字（更不能使用划词翻译）。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04y2ubyw8j31460lm76c.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/reader-view/iibolhpkjjmoepndefdmdlmbpfhlgjpl" target="_blank" rel="noopener">阅读模式</a></p></blockquote><h3 id="13-Octotree"><a href="#13-Octotree" class="headerlink" title="13. Octotree"></a>13. Octotree</h3><p>这个估计不少人知道，它可以在 GitHub 左侧显示当前项目的目录结构，能轻松找到代码的位置。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04ybfedo9j31460lmwhn.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">Octotree</a></p></blockquote><h3 id="14-Enhanced-Github"><a href="#14-Enhanced-Github" class="headerlink" title="14. Enhanced Github"></a>14. Enhanced Github</h3><p>这个可以在 GitHub 中显示仓库大小，每个文件的大小，下载链接和复制文件内容的选项。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04yg4kl8pj31460lm76j.jpg" alt></p><p>要是能够支持单文件夹下载那就更好了。</p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/enhanced-github/anlikcnbgdeidpacdbdljnabclhahhmd" target="_blank" rel="noopener">Enhanced Github</a></p></blockquote><h3 id="15-Isometric-Contributions"><a href="#15-Isometric-Contributions" class="headerlink" title="15. Isometric Contributions"></a>15. Isometric Contributions</h3><p>装X神器，值得拥有。这里放上我心中的偶像 Linus 的贡献图。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04ylt3ugmj31460lmtay.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien" target="_blank" rel="noopener">Isometric Contributions</a></p></blockquote><h3 id="16-Git-History"><a href="#16-Git-History" class="headerlink" title="16. Git History"></a>16. Git History</h3><p>这个扩展可以很炫酷地展示 GitHub 中任意一个文件的历史修改情况。</p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/git-history-browser-exten/laghnmifffncfonaoffcndocllegejnf" target="_blank" rel="noopener">Git History</a></p></blockquote><h3 id="17-Tampermonkey"><a href="#17-Tampermonkey" class="headerlink" title="17. Tampermonkey"></a>17. Tampermonkey</h3><p>油猴怕是没有人不知道，它基本上是所有扩展中的佼佼者了。这里给两个可以发现好用的脚本的网站：</p><ul><li><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">https://greasyfork.org/zh-CN</a></li><li><a href="https://openuserjs.org/" target="_blank" rel="noopener">https://openuserjs.org/</a></li></ul><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a></p></blockquote><h3 id="18-Stylus"><a href="#18-Stylus" class="headerlink" title="18. Stylus"></a>18. Stylus</h3><p>其实类似的扩展还有 Stylish，但它会窃取用户的浏览历史（虽然某位药王说我们更愿意用隐私换便利）。</p><p>而 Stylus 就不会。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g051rdn2pqj31460lmjtk.jpg" alt></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne" target="_blank" rel="noopener">Stylus</a></p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如何你觉得安装太多扩展后严重挤占地址栏的话，可以使用隐藏扩展+快键键的方式。</p><p>最后，如果你也有一些好用的扩展，不妨向我推荐下。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    使用浏览器扩展程序可以使你的工作效率提高数倍不止，那么下面我就向大家分享一下我日常使用的扩展，可能大多数扩展大家都已经在使用了，不过也难免有一两个是你不知道的。&lt;br&gt;    &lt;img src=&quot;https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04uhwp8ozj30hs0b4aal.jpg&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="工具资源" scheme="https://4ark.me/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="https://4ark.me/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Eloquent 时间日期比较和分组</title>
    <link href="https://4ark.me/post/3e85f2e1.html"/>
    <id>https://4ark.me/post/3e85f2e1.html</id>
    <published>2019-02-12T07:03:56.000Z</published>
    <updated>2020-06-13T09:36:01.375Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    最近在做一个订单日收入模块的时候，涉及到日期比较和分组查询的问题，经过一番探索，总算是找到了解决方法，特地记录一下，以方便日后翻阅。<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个订单日收入模块的时候，涉及到日期比较和分组查询的问题，经过一番探索，总算是找到了解决方法，特地记录一下，以方便日后翻阅。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>假设我们有一个<code>orders</code>表，数据如下：</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">amout</th><th style="text-align:center">created_at</th><th style="text-align:center">updated_at</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">100</td><td style="text-align:center">2019-01-01</td><td style="text-align:center">2019-01-01</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">100</td><td style="text-align:center">2019-01-01</td><td style="text-align:center">2019-01-01</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">200</td><td style="text-align:center">2019-01-02</td><td style="text-align:center">2019-01-02</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">200</td><td style="text-align:center">2019-01-02</td><td style="text-align:center">2019-01-02</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">300</td><td style="text-align:center">2019-01-03</td><td style="text-align:center">2019-01-03</td></tr></tbody></table><p>然后我们有以下需求：</p><ol><li>获取每天的收入情况。</li><li>查询某个日期段（或者是某天）的订单，并显示各天的收入情况。</li></ol><h3 id="获取每天的收入情况"><a href="#获取每天的收入情况" class="headerlink" title="获取每天的收入情况"></a>获取每天的收入情况</h3><p>其实这个问题的难点就在于如何按照日期来分组，我的解决方案如下：</p><pre><code class="php">public function getIncome(Request $request){    $list = Order::query() // 这里可以用 where 先限制一些条件                -&gt;select(                    DB::raw(&#39;Date(created_at) as date&#39;),                    DB::raw(&#39;COUNT(id) as count&#39;),                    DB::raw(&#39;SUM(amount) as income&#39;)                );    return $list-&gt;groupBy(&#39;date&#39;)                -&gt;orderBy(&#39;date&#39;, &#39;DESC&#39;)                -&gt;get();}</code></pre><p>返回结果如下：</p><pre><code class="json">[  {    &quot;date&quot;: &quot;2019-01-03&quot;,    &quot;count&quot;: 1,    &quot;income&quot;: 300  },  {    &quot;date&quot;: &quot;2019-01-02&quot;,    &quot;count&quot;: 2,    &quot;income&quot;: 400  },  {    &quot;date&quot;: &quot;2019-01-01&quot;,    &quot;count&quot;: 2,    &quot;income&quot;: 200  }]</code></pre><h3 id="获取某个日期段的各天收入情况"><a href="#获取某个日期段的各天收入情况" class="headerlink" title="获取某个日期段的各天收入情况"></a>获取某个日期段的各天收入情况</h3><p>这里就涉及到日期比较了，因此我们可以使用<code>whereDate</code>方法。</p><p><strong>注</strong> ：</p><blockquote><p><code>whereDate</code>方法只能在 <code>Laravel 5.0</code>之后才能使用。</p><p>关于更多类似日期方法可以访问: <a href="https://www.cnblogs.com/huangshoushi/p/5875022.html" target="_blank" rel="noopener">链接</a></p></blockquote><p>我们需要接受两个参数：</p><pre><code class="php">public function getIncome(Request $request){    $list = Order::query() // 这里可以用 where 先限制一些条件                -&gt;select(                    DB::raw(&#39;Date(created_at) as date&#39;),                    DB::raw(&#39;COUNT(id) as count&#39;),                    DB::raw(&#39;SUM(amount) as income&#39;)                );    if ($request-&gt;has(&#39;date&#39;)){            $date = $request-&gt;input(&#39;date&#39;);            $list = $list-&gt;whereDate(&#39;created_at&#39;,&#39;&gt;=&#39;,$date[0])                         -&gt;whereDate(&#39;created_at&#39;,&#39;&lt;=&#39;,$date[1]);    }    return $list-&gt;groupBy(&#39;date&#39;)                -&gt;orderBy(&#39;date&#39;, &#39;DESC&#39;)                -&gt;get();}</code></pre><p>返回结果：</p><pre><code class="json">[  {    &quot;date&quot;: &quot;2019-01-02&quot;,    &quot;count&quot;: 2,    &quot;income&quot;: 400  },  {    &quot;date&quot;: &quot;2019-01-01&quot;,    &quot;count&quot;: 2,    &quot;income&quot;: 200  }]</code></pre><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="获取当天"><a href="#获取当天" class="headerlink" title="获取当天"></a>获取当天</h4><p>获取当天可以这样：</p><pre><code class="php">Order-&gt;whereDate(&#39;created_at&#39;, date(&quot;Y-m-d&quot;));</code></pre><h4 id="满足其他条件"><a href="#满足其他条件" class="headerlink" title="满足其他条件"></a>满足其他条件</h4><p>假设我们还要当天总收入超过多少才行，我们可以这样：</p><pre><code class="php">$list = $list-&gt;havingRaw(&#39;SUM(amount) &#39; . &#39;&gt;&#39; . &#39; &#39; . $minAmount);</code></pre><p>或者需要当订单数量超过多少：</p><pre><code class="php">$list = $list-&gt;havingRaw(&#39;COUNT(id) &#39; . &#39;&gt;&#39; . &#39; &#39; . $minCount);</code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>当然，我这个可能不是最佳方案，如果您有更好的方法，还请多多指教。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    最近在做一个订单日收入模块的时候，涉及到日期比较和分组查询的问题，经过一番探索，总算是找到了解决方法，特地记录一下，以方便日后翻阅。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="后端" scheme="https://4ark.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="后端" scheme="https://4ark.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>分享一些好用的网站</title>
    <link href="https://4ark.me/post/a12c2740.html"/>
    <id>https://4ark.me/post/a12c2740.html</id>
    <published>2019-02-10T10:10:17.000Z</published>
    <updated>2020-06-13T09:36:01.377Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>这两年收藏了不少网站，特地整理一下，把一些大家都可能用得上的分享出来，希望能对你有用。<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01kfsb325j31460lm78s.jpg"><br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两年收藏了不少网站，特地整理一下，把一些大家都可能用得上的分享出来，希望能对你有用。</p><p>考虑到有一些网站大多数人都知道，所以我就不列出来了。</p><p>我把这些网站分为了几大类：</p><ul><li>工具类</li><li>素材类</li><li>社区类</li></ul><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="1、start-me（收藏工具）"><a href="#1、start-me（收藏工具）" class="headerlink" title="1、start.me（收藏工具）"></a>1、start.me（收藏工具）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01kfsb325j31460lm78s.jpg" alt></p><p>它不仅仅是一个网址收藏管理器，它还可以：推送、嵌入任何东西、集成、自定义、分享你的收藏夹、浏览器扩展。</p><p>很明显本文所分享的网站就是靠它来保存的，用它的理由两个就够了：</p><ol><li>可以在不同设备中共享书签。</li><li>域名好记。</li></ol><blockquote><p>网站链接：<a href="https://start.me" target="_blank" rel="noopener">https://start.me</a></p></blockquote><h3 id="2、Placemat（快速生成占位图片器）"><a href="#2、Placemat（快速生成占位图片器）" class="headerlink" title="2、Placemat（快速生成占位图片器）"></a>2、Placemat（快速生成占位图片器）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01kofjhs1j31460lm0v6.jpg" alt></p><p>如果你是前端，就有可能会遇到需要占位图来填充网页的情况，而 Placemat 就是用来生成占位图的。</p><p>最基本的用法是：给定参数<code>w</code>或<code>h</code>，Placemat  会随机返回相应尺寸的图片，其他用法自行探究。</p><p>使用 Placemat  的好处显而易见。</p><blockquote><p>网站链接：<a href="https://placem.at" target="_blank" rel="noopener">https://placem.at</a></p></blockquote><h3 id="3、Carbon（代码界美图秀秀）"><a href="#3、Carbon（代码界美图秀秀）" class="headerlink" title="3、Carbon（代码界美图秀秀）"></a>3、Carbon（代码界美图秀秀）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01l4ctkw0j31460lm40t.jpg" alt></p><p>这个无需多言，明眼人一看就知道是用来装什么的 :)</p><blockquote><p>网站链接：<a href="https://carbon.now.sh" target="_blank" rel="noopener">https://carbon.now.sh</a></p></blockquote><h3 id="4、TinyPNG（在线压缩图片）"><a href="#4、TinyPNG（在线压缩图片）" class="headerlink" title="4、TinyPNG（在线压缩图片）"></a>4、TinyPNG（在线压缩图片）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01l85eym5j31460lmqgs.jpg" alt></p><p>图片压缩界的一哥了，支持同时上传多张图片。很好用，压缩率也很高，最重要的是，速度很快。</p><blockquote><p>网站链接：<a href="https://tinypng.com" target="_blank" rel="noopener">https://tinypng.com</a></p></blockquote><h3 id="5、两个在线截图工具"><a href="#5、两个在线截图工具" class="headerlink" title="5、两个在线截图工具"></a>5、两个在线截图工具</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01lebp7hsj31460lm0ur.jpg" alt></p><p>BrowserFrame 是一个生成浏览器外壳的网站，它提供了两种方式来生成截图，分别是：</p><ol><li>上传本地截图</li><li>输入网址生成截图（可能挂了，经常不成功）</li></ol><p><strong>注：</strong>推荐另一个功能类似的网站 Screen Guru，它可以实现通过网址生成截图功能，看下图。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01lqsaguqj315s0sa0uf.jpg" alt></p><p>这样截图逼格瞬间提升百倍有木有 :)</p><blockquote><p>网站链接1：<a href="https://browserframe.com" target="_blank" rel="noopener">https://browserframe.com</a></p><p>网站链接2：<a href="https://screen.guru" target="_blank" rel="noopener">https://screen.guru</a></p></blockquote><h3 id="6、ColorSpark（在线随机颜色）"><a href="#6、ColorSpark（在线随机颜色）" class="headerlink" title="6、ColorSpark（在线随机颜色）"></a>6、ColorSpark（在线随机颜色）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01m1i2yflj31460lmmy5.jpg" alt></p><p>随机生成好看的颜色、渐变色，可以一键复制 CSS 代码。</p><blockquote><p>网站链接：<a href="https://colorspark.app" target="_blank" rel="noopener">https://colorspark.app</a></p></blockquote><h3 id="7、FontSpark（在线预览字体）"><a href="#7、FontSpark（在线预览字体）" class="headerlink" title="7、FontSpark（在线预览字体）"></a>7、FontSpark（在线预览字体）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01m2n6sy4j31460lm0ts.jpg" alt></p><p>随机字体在线预览，用过都说好。</p><blockquote><p>网站链接：<a href="https://fontspark.app" target="_blank" rel="noopener">https://fontspark.app</a></p></blockquote><h3 id="8、easy-PDF（在线-PDF-工具）"><a href="#8、easy-PDF（在线-PDF-工具）" class="headerlink" title="8、easy PDF（在线 PDF 工具）"></a>8、easy PDF（在线 PDF 工具）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01m69eod2j31460lmwg6.jpg" alt></p><p>功能看上图。</p><blockquote><p>网站链接：<a href="https://easypdf.com/cn" target="_blank" rel="noopener">https://easypdf.com/cn</a></p></blockquote><h2 id="素材类"><a href="#素材类" class="headerlink" title="素材类"></a>素材类</h2><h3 id="1、觅元素（免抠素材）"><a href="#1、觅元素（免抠素材）" class="headerlink" title="1、觅元素（免抠素材）"></a>1、觅元素（免抠素材）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01mae8r2xj31460lmapg.jpg" alt></p><p>在国内算是相对良心的网站了，一天有5次免费下载机会，上面素材质量很高，简直是做 PPT 必备。</p><blockquote><p>网站链接：<a href="http://www.51yuansu.com" target="_blank" rel="noopener">http://www.51yuansu.com</a></p></blockquote><h3 id="2、高清无版权图片网站"><a href="#2、高清无版权图片网站" class="headerlink" title="2、高清无版权图片网站"></a>2、高清无版权图片网站</h3><p>这里只列出国内访问速度还算可以的，但是不一一贴图了，有兴趣可以自行查看。</p><ol><li><a href="https://www.pexels.com/" target="_blank" rel="noopener">Pexels</a></li><li><a href="https://picjumbo.com/" target="_blank" rel="noopener">Picjumbo</a></li><li><a href="https://magdeleine.co/" target="_blank" rel="noopener">Magdeleine</a></li><li><a href="https://pixabay.com/" target="_blank" rel="noopener">Pixabay</a></li><li><a href="https://www.ssyer.com/home" target="_blank" rel="noopener">Ssyer</a></li><li><a href="https://www.lifeofpix.com/" target="_blank" rel="noopener">Lifeofpix</a></li></ol><h3 id="3、UI设计师导航"><a href="#3、UI设计师导航" class="headerlink" title="3、UI设计师导航"></a>3、UI设计师导航</h3><p>想看更多的可以去这几个导航看看。</p><ol><li><a href="http://so.uigreat.com/" target="_blank" rel="noopener">http://so.uigreat.com/</a></li><li><a href="http://hao.shejidaren.com/" target="_blank" rel="noopener">http://hao.shejidaren.com/</a></li><li><a href="http://hao.uisdc.com/" target="_blank" rel="noopener">http://hao.uisdc.com/</a></li><li><a href="http://www.tuyiyi.com/hao/" target="_blank" rel="noopener">http://www.tuyiyi.com/hao/</a></li></ol><h2 id="社区类"><a href="#社区类" class="headerlink" title="社区类"></a>社区类</h2><h3 id="1、CSS-TRICKS"><a href="#1、CSS-TRICKS" class="headerlink" title="1、CSS-TRICKS"></a>1、CSS-TRICKS</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01nfctm73j31460lmqal.jpg" alt></p><p>一个国外的优秀前端开发博客，主要分享使用 CSS 样式的技巧，经验和教程等。值得前端开发者阅读收藏的国外网站。</p><blockquote><p>网站链接：<a href="https://css-tricks.com" target="_blank" rel="noopener">https://css-tricks.com</a></p></blockquote><h3 id="2、踏得网"><a href="#2、踏得网" class="headerlink" title="2、踏得网"></a>2、踏得网</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01ni3d6wpj31460lmjwh.jpg" alt></p><p>算是国内版的 <a href="https://codepen.io/" target="_blank" rel="noopener">CodePen</a>，其中不乏一些惊艳的动画、特性。</p><h3 id="3、免费资源网络社区"><a href="#3、免费资源网络社区" class="headerlink" title="3、免费资源网络社区"></a>3、免费资源网络社区</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01nm0f36ej31460lmaf0.jpg" alt></p><p>免费资源网络社区是一个以免费为主题的台湾网站、部落格，内容包含科技新知、免费软体、线上工具、图库素材、WordPress 架站及应用程式介绍教学。</p><p>我不会告诉你上面大多数网站都是从这里看到的。</p><blockquote><p>网站链接：<a href="https://free.com.tw" target="_blank" rel="noopener">https://free.com.tw</a></p></blockquote><h3 id="4、前端里"><a href="#4、前端里" class="headerlink" title="4、前端里"></a>4、前端里</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01nnppxtrj31460lm49o.jpg" alt></p><p>前端里专注于分享最前沿的Web开发技术，教程，资源和素材，是面向网站开发人员和设计师的学习交流平台。</p><blockquote><p>网站链接：<a href="http://www.yyyweb.com" target="_blank" rel="noopener">http://www.yyyweb.com</a></p></blockquote><h3 id="5、伯乐在线"><a href="#5、伯乐在线" class="headerlink" title="5、伯乐在线"></a>5、伯乐在线</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01no7r779j31460lmwgo.jpg" alt></p><p>伯乐在线资源收录各种开发、设计、系统管理与安全相关的工具与资源。</p><blockquote><p>网站链接：<a href="http://hao.jobbole.com" target="_blank" rel="noopener">http://hao.jobbole.com</a></p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>拥有自己的工具箱可以有效地提高你的工作效率，从而有更多的时间投入到真正开发之中。</p><p>下一篇，我打算分享一些我在 Chrome 中常用的那些扩展（本文截图使用的工具就是 Chrome 的扩展，Standardized Screenshot）。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;这两年收藏了不少网站，特地整理一下，把一些大家都可能用得上的分享出来，希望能对你有用。&lt;br&gt;&lt;img src=&quot;https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01kfsb325j31460lm78s.jpg&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="工具资源" scheme="https://4ark.me/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="https://4ark.me/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue + Element UI + Lumen 实现通用表格功能 - 分页</title>
    <link href="https://4ark.me/post/64f1da47.html"/>
    <id>https://4ark.me/post/64f1da47.html</id>
    <published>2019-02-01T07:19:47.000Z</published>
    <updated>2020-06-13T09:36:01.375Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>最近在做一个前后端分离的项目，前端使用 <code>Vue</code>+ <code>Element UI</code>，而后端则使用 <code>Lumen</code> 做接口开发，其中分页是必不可少的一部分，本文就介绍如何基于以上环境做一个简单、可复用的分页功能。<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个前后端分离的项目，前端使用 <code>Vue</code>+ <code>Element UI</code>，而后端则使用 <code>Lumen</code> 做接口开发，其中分页是必不可少的一部分，本文就介绍如何基于以上环境做一个简单、可复用的分页功能。</p><h2 id="先说后端"><a href="#先说后端" class="headerlink" title="先说后端"></a>先说后端</h2><p>后端做的事情不多，只需要接受几个参数，根据参数来获取数据即可。</p><p>需要获取的参数如下：</p><ul><li><code>pageSize</code>（一页数据的数量）</li><li><code>pageIndex</code>（第几页的数据）</li></ul><p>然后就可以根据这两个参数计算出偏移量，再从数据库中取出相应的数据。</p><p>假如现在给出的参数为：<code>pageSize=10</code>，<code>pageIndex = 2</code>，也就是说每一页要10条记录，要第二页。</p><p>计算偏移量的公式为：<code>pageSize * (pageIndex - 1)</code>。</p><p>基本代码如下：</p><pre><code class="php">public function getUser(Request $request){    $pageSize = $request-&gt;input(&#39;pageSize&#39;);    $pageIndex = $request-&gt;input(&#39;pageIndex&#39;);    $offset = $pageSize * ($pageIndex - 1);    return User::offset($offset)                -&gt;limit($pageSize)                -&gt;get();}</code></pre><p>后端基本上只需要做这么多，就可以完成一个分页的功能了，但还是有几处地方需要改进一下：</p><ul><li>给参数一个默认值</li><li>前端还需要知道整个表的数据的总数</li><li>把分页做成一个公用的函数</li></ul><p>改进后的代码如下：</p><pre><code class="php">private $default_page_size = 30;private $default_page_index = 1;// 公用分页public function pagination($request, $list) {    $pageSize = $request-&gt;input(&#39;pageSize&#39;, $this-&gt;default_page_size);    $pageIndex = $request-&gt;input(&#39;pageIndex&#39;, $this-&gt;default_page_index);    $offset = $pageSize * ($pageIndex - 1);    $total = $list-&gt;count();    $list = $list            -&gt;offset($offset)            -&gt;limit($pageSize);    return [        &#39;list&#39; =&gt; $list-&gt;get(),        &#39;total&#39; =&gt; $total,    ];}// 获取用户列表public function getUser(Request $request) {    $list = User::query();    /*        这里可以做一些查询之类的操作    */    return $this-&gt;pagination($request, $list);}</code></pre><h2 id="再说前端"><a href="#再说前端" class="headerlink" title="再说前端"></a>再说前端</h2><p>前端相对于需要做的事情就比较多了，需要考虑几点：</p><ul><li>获取数据时需要带上分页的参数</li><li>分页参数需要进行本地持久化，以免刷新页面回到第一页（后端设置的默认值）</li><li>同样要抽象出一个通用的分页组件</li></ul><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>这里我们用 <code>vuex</code>来管理状态，然后在请求时带上分页数据：</p><p>store.js：</p><blockquote><p><strong>注意</strong>：</p><ul><li>这里为了方便展示代码，并没有使用模块化，项目中，最好将使用模块化方便管理。</li><li>这里默认读者清楚 ES6 的语法</li></ul></blockquote><pre><code class="javascript">export default new vuex.Store({    state : {        user : {            list: [],            total: 0,            pageIndex: 1,            pageSize: 10,        }    },    mutations: {        updateUser(state, data) {            state.user = {                ...state.user,                ...data,            }        },      },    actions: {        async getUser({commit,state,getters}) {            // $axios 只是我自己封装的一个函数 这里并不重要            const res = await $axios.get(&#39;/user&#39;,getters.requestData(state.user))            commit(&#39;updateUser&#39;,res);        },    },    getters:{        requestData(state) {            return (origin) =&gt; {                const {                    pageIndex,                    pageSize,                } = origin;                const data = {                    pageIndex,                    pageSize,                };                return data;            }        },    }})</code></pre><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>现在如何获取数据已经搞定了，数据持久化我使用 <a href="https://github.com/crossjs/vuex-localstorage" target="_blank" rel="noopener">vuex-localstorage</a>，安装后，只需要在上面代码的基础上添加：</p><pre><code class="javascript">import createPersist from &#39;vuex-localstorage&#39;export default new vuex.Store({    // 接着上面的    plugins: [createPersist({        namespace: &#39;studio-user&#39;,        initialState: {},        // ONE_WEEK        expires: 7 * 24 * 60 * 60 * 1e3    })]})</code></pre><h3 id="公用分页组件"><a href="#公用分页组件" class="headerlink" title="公用分页组件"></a>公用分页组件</h3><pre><code class="html">&lt;template&gt;  &lt;el-Pagination    background    layout=&quot;total, sizes, prev, pager, next, jumper&quot;    :total=&quot;module.total&quot;    :current-page.sync=&quot;module.pageIndex&quot;    :page-sizes=&quot;module.pageSizes&quot;    :page-size.sync=&quot;module.pageSize&quot;    @current-change=&quot;handleCurrentChange&quot;    @size-change=&quot;handleSizeChange&quot;  &gt;  &lt;/el-Pagination&gt;&lt;/template&gt;&lt;script&gt;export default {  props: {    module: Object  },  methods: {    getData() {      this.$emit(&quot;get-data&quot;);    },    handleCurrentChange() {      this.getData();    },    handleSizeChange(val) {      this.getData();    }  }};&lt;/script&gt;</code></pre><h3 id="使用分页组件"><a href="#使用分页组件" class="headerlink" title="使用分页组件"></a>使用分页组件</h3><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;el-table        :data=&quot;user.list&quot;        style=&quot;width: 100%;&quot;      &gt;        &lt;el-table-column          v-for=&quot;(item,index) in columns&quot;          :key=&quot;index&quot;          :prop=&quot;item.prop&quot;          :label=&quot;item.label&quot;          align=&quot;center&quot;        /&gt;      &lt;/el-table&gt;      &lt;pagination        :module=&quot;user&quot;        @get-data=&quot;getData&quot;      /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Pagination from &quot;@/common/components/Pagination&quot;;import { mapActions, mapState } from &quot;vuex&quot;;export default {  components: {    Pagination,  },  data: () =&gt; ({    columns: [      {        prop: &quot;name&quot;,        label: &quot;姓名&quot;      },      {        prop: &quot;性别&quot;,        label: &quot;sex&quot;      },      {        prop: &quot;年龄&quot;,        label: &quot;age&quot;      },    ]  }),  created() {    this.getData();  },  methods: {      ...mapActions({          getData : &quot;getUser&quot;,      })     },  computed: {    ...mapState([&quot;user&quot;])  }};&lt;/script&gt;</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>将一些常用的功能抽象出来，打造一个自己的工具库，从而使开发效率更高。</p><p>最后，安利一下文章开头说的项目：<a href="https://github.com/gd4Ark/learn_english" target="_blank" rel="noopener">清技背单词</a>，上面的代码就是从这个项目中<code>copy</code>出来后略作修改的。</p><p>感谢观看，希望我的文章能对您有一些帮助！</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;最近在做一个前后端分离的项目，前端使用 &lt;code&gt;Vue&lt;/code&gt;+ &lt;code&gt;Element UI&lt;/code&gt;，而后端则使用 &lt;code&gt;Lumen&lt;/code&gt; 做接口开发，其中分页是必不可少的一部分，本文就介绍如何基于以上环境做一个简单、可复用的分页功能。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://4ark.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://4ark.me/categories/%E5%89%8D%E7%AB%AF/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://4ark.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>解决 Laravel JWT 多表认证时获取不到当前认证用户的问题</title>
    <link href="https://4ark.me/post/834cec76.html"/>
    <id>https://4ark.me/post/834cec76.html</id>
    <published>2019-01-29T06:47:02.000Z</published>
    <updated>2020-06-13T09:36:01.379Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    最近在做一个项目，需要多表认证，分别为<code>admin</code>和<code>user</code>表，我采用的<code>JWT</code>认证方式，但今天遇到了一个问题：使用<code>Auth::user()</code>返回<code>null</code>，也就是说无法获得当前认证的用户。<br></div><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近在做一个项目，需要多表认证，分别为<code>admin</code>和<code>user</code>表，我采用的<code>JWT</code>认证方式，但今天遇到了一个问题：使用<code>Auth::user()</code>返回<code>null</code>，也就是说无法获得当前认证的用户。</p><p>网上搜索后，并没有找到直接的解决方案，然后经过几次尝试居然误打误撞地解决了，所以特地记录下来，希望遇到同样问题的人不要再在这问题上耗费太多时间。</p><p><strong>注意：</strong>这里并不介绍<code>JWT</code>的工作原理和配置，如果想理解更多请参考以下文章：</p><ul><li><a href="https://learnku.com/articles/10885/full-use-of-jwt" target="_blank" rel="noopener">JWT 完整使用详解</a></li><li><a href="https://learnku.com/articles/10889/detailed-implementation-of-jwt-extensions" target="_blank" rel="noopener">JWT 扩展具体实现详解</a></li></ul><h2 id="大致配置"><a href="#大致配置" class="headerlink" title="大致配置"></a>大致配置</h2><p>先讲一下我的配置。</p><p><code>auth.php</code>文件如下：</p><pre><code class="php">return [    &#39;defaults&#39; =&gt; [        &#39;guard&#39; =&gt; env(&#39;AUTH_GUARD&#39;, &#39;admin&#39;),    ],    &#39;guards&#39; =&gt; [        &#39;admin&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;jwt&#39;,                           #### 更改为JWT驱动            &#39;provider&#39; =&gt; &#39;admins&#39;,        ],        &#39;user&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;jwt&#39;,                           #### 更改为JWT驱动            &#39;provider&#39; =&gt; &#39;users&#39;,        ],    ],    &#39;providers&#39; =&gt; [        &#39;admins&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39;  =&gt; \App\Admin::class,        #### 指定用于token验证的模型类        ],        &#39;users&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39;  =&gt; \App\User::class,        #### 指定用于token验证的模型类        ],    ],    &#39;passwords&#39; =&gt; [        //    ],];</code></pre><h2 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h2><p>在<code>auth.php</code>中，我们有两个<code>guard</code>，而默认的<code>guard</code>指向的是<code>admin</code>，这时候如果是<code>user</code>经过的验证的话，是无法通过<code>Auth::user()</code>获取到当前认证用户信息的。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法很简单，只要使用<code>Auth::guard(&#39;user&#39;)</code>指明使用哪个<code>guard</code>即可，这里我是通过公用的控制器中的一个方法：</p><pre><code class="php">public function getAuthUser($guard = &#39;admin&#39;){    return Auth::guard($guard)-&gt;user();}</code></pre><p>感谢观看！</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    最近在做一个项目，需要多表认证，分别为&lt;code&gt;admin&lt;/code&gt;和&lt;code&gt;user&lt;/code&gt;表，我采用的&lt;code&gt;JWT&lt;/code&gt;认证方式，但今天遇到了一个问题：使用&lt;code&gt;Auth::user()&lt;/code&gt;返回&lt;code&gt;null&lt;/code&gt;，也就是说无法获得当前认证的用户。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="后端" scheme="https://4ark.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="后端" scheme="https://4ark.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>理解 JavaScript 中的原型</title>
    <link href="https://4ark.me/post/6a052002.html"/>
    <id>https://4ark.me/post/6a052002.html</id>
    <published>2019-01-20T04:09:05.000Z</published>
    <updated>2020-06-13T09:36:01.379Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    JavaScript 中的原型一直是我很惧怕的一个主题，理由很简单，因为真的不好理解，但它确实是 JavaScript 中很重要的一部分，而且是面试的必考题，就算现在不懂，以后迟早有一天要把它弄懂，不然的话永远都没办法把自己的技术能力往上提高一个层次，所以今天就来讲讲 JavaScript 中的原型。<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中的原型一直是我很惧怕的一个主题，理由很简单，因为真的不好理解，但它确实是 JavaScript 中很重要的一部分，而且是面试的必考题，就算现在不懂，以后迟早有一天要把它弄懂，不然的话永远都没办法把自己的技术能力往上提高一个层次，所以今天就来讲讲 JavaScript 中的原型。</p><p>本文是这系列的第四篇，往期文章：</p><ol><li><a href="https://juejin.im/post/5c386bd96fb9a04a03796f93" target="_blank" rel="noopener">理解 JavaScript 中的作用域</a></li><li><a href="https://juejin.im/post/5c3893bc6fb9a049d37f530f" target="_blank" rel="noopener">理解 JavaScript 中的闭包</a></li><li><a href="https://gd4ark.github.io/2019/01/16/%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84this/" target="_blank" rel="noopener">理解 JavaScript 中的 this</a></li></ol><h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>首先要说一下为什么会有原型这个东西，那是因为在 JavaScript 中并没有 “类” 的概念，它是靠原型和原型链实现对象属性的继承，即便在 ES6 中新出了<code>class</code>的语法，但那也只是一个语法糖，它的底层依然是原型。</p><p>要理解原型（原型链），最重要的是理解两个属性以及它们之间的关系：</p><ul><li><code>__proto__</code></li><li><code>prototype</code></li></ul><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>JavaScript中，万物皆对象，所有的对象都有<code>__proto__</code>属性（<code>null</code>和<code>undefined</code>除外），而且指向创造这个对象的函数对象的<code>prototype</code>属性。</p><pre><code class="javascript">var obj = {};console.log( obj.__proto__ === Object.prototype ); // truevar arr = [];console.log( arr.__proto__ === Array.prototype ); // truevar fn = function(){};console.log( fn.__proto__ === Function.prototype ); // truevar str = &quot;&quot;;console.log( str.__proto__ === String.prototype ); // truevar num = 1;console.log( num.__proto__ === Number.prototype ); // true</code></pre><p>前面说了，在 JavaScript 中，一切皆对象（可以理解为它们都是从对象那里继承过来的），所以：</p><pre><code class="javascript">console.log( Function.prototype.__proto__ === Object.prototype ); // trueconsole.log( Array.prototype.__proto__ === Object.prototype ); // trueconsole.log( String.prototype.__proto__ === Object.prototype ); // true</code></pre><p>而因为<code>Object.prototype</code>的<code>__proto__</code>已经是终点了，所以它的指向是：</p><pre><code class="javascript">console.log( Object.prototype.__proto__ === null ); // true</code></pre><p><strong>注意</strong>，虽然大多数浏览器都支持通过<code>__proto__</code>来访问，但它并不是<code>ECMAScript</code>的标准，在 ES5 中可以通过<code>Object.getPrototypeOf()</code>来获取这个属性。</p><pre><code class="javascript">var obj = {};console.log( Object.getPrototypeOf(obj) === Object.prototype ); // true</code></pre><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h3><p> <code>prototype</code>是每个函数对象都具有的属性（它也有<code>__proto__</code>，因为函数也是对象），实例化创建出来的对象会共享此<code>prototype</code>里的属性和方法（通过<code>__proto__</code>）。</p><p>在上面的例子中已经看到过<code>prototype</code>的身影，下面通过一个例子来讲述它的作用。</p><p>现在我们有一个构造函数<code>Person</code>，并且对它进行实例化：</p><pre><code class="javascript">function Person(name){    this.name = name;    this.sayName = function(){        console.log(&quot;我的名字是：&quot; + this.name);    }}var a = new Person(&quot;小明&quot;);var b = new Person(&quot;小红&quot;);a.sayName(); // 我的名字是：小明b.sayName(); // 我的名字是：小红</code></pre><h4 id="new运算符的缺点"><a href="#new运算符的缺点" class="headerlink" title="new运算符的缺点"></a>new运算符的缺点</h4><p>但是，用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</p><p>例如上面例子中的<code>a</code>和<code>b</code>，它们都有<code>sayName</code>方法，虽然做的事相同，但它们却是独立的，这就会造成极大的资源浪费，因为每一个实例对象，都有自己的属性和方法的副本。</p><h4 id="prototype属性的引入"><a href="#prototype属性的引入" class="headerlink" title="prototype属性的引入"></a>prototype属性的引入</h4><p>考虑到这一点，Brendan Eich 决定为构造函数设置一个<code>prototype</code>属性。</p><p>这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面，而不需要共享属性和方法，就放在构造函数里面，这个对象就是<code>prototype</code>对象。</p><p>实例对象一旦创建，将自动引用<code>prototype</code>对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p><p>现在对上面的例子进行改写：</p><pre><code class="javascript">function Person(name){    this.name = name;}Person.prototype = {    sayName : function(){        console.log(&quot;我的名字是：&quot; + this.name);    }}var a = new Person(&quot;小明&quot;);var b = new Person(&quot;小红&quot;);a.sayName() // 我的名字是：小明b.sayName() // 我的名字是：小红</code></pre><p>现在无论<code>Person</code>被实例化多少次，它的实例对象都共享同一个<code>sayName</code>方法，这就是<code>prototype</code>最大的用处。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>讲原型一个不可避免的概念就是原型链，原型链是通过<code>__proto__</code>来实现的。</p><p>现在我们以<code>Person</code>的例子来讲整个原型链。</p><pre><code class="javascript">var a = new Person(&quot;小明&quot;);// 实例化对象的 __proto__ 指针指向构造函数的原型console.log( a.__proto__ === Person.prototype )// 构造函数的原型是一个对象，它的 __proto__ 指向对象的原型console.log( Person.prototype.__proto__ === Object.prototype )// 函数也是一个对象，它的 __proto__ 指向 函数的原型console.log( Person.__proto__ === Function.prototype )// 函数的原型是一个对象，它的 __proto__ 指向对象的原型console.log( Function.prototype.__proto__ === Object.prototype )// 对象的原型的__proto__ 指向 nullconsole.log( Object.prototype.__proto__ === null )</code></pre><p>以上就是<code>a</code>对象的整个原型链。</p><h2 id="属性查找机制"><a href="#属性查找机制" class="headerlink" title="属性查找机制"></a>属性查找机制</h2><p>当访问一个对象的属性时，Javascript  会从对象本身开始往上遍历整个原型链，直到找到对应属性为止。如果此时到达了原型链的顶部，也就是上例中的 <code>Object.prototype</code>，仍然未发现需要查找的属性，那么 Javascript 就会返回 <code>undefined</code>值。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    JavaScript 中的原型一直是我很惧怕的一个主题，理由很简单，因为真的不好理解，但它确实是 JavaScript 中很重要的一部分，而且是面试的必考题，就算现在不懂，以后迟早有一天要把它弄懂，不然的话永远都没办法把自己的技术能力往上提高一个层次，所以今天就来讲讲 JavaScript 中的原型。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://4ark.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Lumen 使用 throttle 限制接口访问频率</title>
    <link href="https://4ark.me/post/618b271f.html"/>
    <id>https://4ark.me/post/618b271f.html</id>
    <published>2019-01-18T10:22:31.000Z</published>
    <updated>2020-06-13T09:36:01.375Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    今天碰到过这样一个情况，我需要限制用户请求某个<code>API</code>接口的频率，比如登录、反馈等提交操作，经过一番搜索+折腾，总算是实现了。<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天碰到过这样一个情况，我需要限制用户请求某个<code>API</code>接口的频率，比如登录、反馈等提交操作，经过一番搜索+折腾，总算是实现了。</p><blockquote><p>在<code>Laravel 5.2</code>的新特性中增加了一个<code>throttle</code>中间件，通过它可以在路由层限制<code>API</code>访问的频率。例如限制频率为1分钟50次，如果一分钟内超过了这个限制，它就会响应：429: Too Many Attempts。</p></blockquote><p>但我在项目中使用的是<code>Lumen</code>框架（它只有<code>Laravel</code>中的一部分功能），它并没有集成这个中间件，所以本文主要是讲述如何在<code>Lumen</code>框架中加入<code>throttle</code>中间件。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先我们要在<code>app\Http\Middleware</code>中新建<code>ThrottleRequests.php</code>文件。</p><p>并且把以下链接中的代码拷贝到这个文件中：</p><p><a href="https://github.com/illuminate/routing/blob/master/Middleware/ThrottleRequests.php" target="_blank" rel="noopener">https://github.com/illuminate/routing/blob/master/Middleware/ThrottleRequests.php</a></p><p>接着修改文件中的命名空间：</p><pre><code class="php">namespace App\Http\Middleware;</code></pre><h3 id="标记同一用户端请求"><a href="#标记同一用户端请求" class="headerlink" title="标记同一用户端请求"></a>标记同一用户端请求</h3><p>因为<code>Lumen</code>框架缺失部分功能，我们需要修改<code>ThrottleRequests.php</code>中的<code>resolveRequestSignature</code>方法：</p><pre><code class="php">protected function resolveRequestSignature($request){    return sha1(        $request-&gt;method() .        &#39;|&#39; . $request-&gt;server(&#39;SERVER_NAME&#39;) .        &#39;|&#39; . $request-&gt;path() .        &#39;|&#39; . $request-&gt;ip()    );}</code></pre><h3 id="抛出响应"><a href="#抛出响应" class="headerlink" title="抛出响应"></a>抛出响应</h3><p><code>throttle</code>超过限制时抛出的是<code>Illuminate\Http\Exceptions\ThrottleRequestsException</code>，同样<code>Lumen</code>框架缺少这个文件，需要自己定义一下，在<code>app/Exceptions</code>中新建<code>ThrottleException.php</code>，写入以下代码：</p><pre><code class="php">&lt;?phpnamespace App\Exceptions;use Exception;class ThrottleException extends Exception{    protected $isReport = false;    public function isReport(){        return $this-&gt;isReport;    }}</code></pre><p>在<code>app/Exceptions/Handler.php</code>捕获该抛出异常，在<code>render</code>方法增加以下判断：</p><pre><code class="php">if ($exception instanceof ThrottleException) {    return response([        &#39;code&#39; =&gt; $exception-&gt;getCode(),        &#39;msg&#39; =&gt; $exception-&gt;getMessage()    ], 429);}</code></pre><p>修改<code>ThrottleRequests.php</code>文件中的<code>buildException</code>方法：</p><pre><code class="php">protected function buildException($key, $maxAttempts){    $retryAfter = $this-&gt;getTimeUntilNextRetry($key);    $headers = $this-&gt;getHeaders(        $maxAttempts,        $this-&gt;calculateRemainingAttempts($key, $maxAttempts, $retryAfter),        $retryAfter    );    // 修改了这一行      return new ThrottleException(&#39;Too Many Attempts.&#39;, 429);}</code></pre><blockquote><p>需在文件头部中添加这一行：<code>use App\Exceptions\ThrottleException;</code></p></blockquote><h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><p>在<code>bootstrap/app.php</code>中注册：</p><pre><code class="php">$app-&gt;routeMiddleware([     &#39;throttle&#39; =&gt; App\Http\Middleware\ThrottleRequests::class,]);</code></pre><p>到这里我们就加入成功了，接着在路由中添加中间件即可：</p><pre><code class="php"> $router-&gt;group([&#39;middleware&#39; =&gt; [&#39;throttle:10,2&#39;]],function() use ($router){    $router-&gt;post(&#39;feedback&#39;,&#39;UserController@addFeedback&#39;);});</code></pre><p>其中<code>throttle:10,2</code>表示的是2分钟内访问10次。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    今天碰到过这样一个情况，我需要限制用户请求某个&lt;code&gt;API&lt;/code&gt;接口的频率，比如登录、反馈等提交操作，经过一番搜索+折腾，总算是实现了。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="后端" scheme="https://4ark.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="后端" scheme="https://4ark.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>理解 JavaScript 中的 this</title>
    <link href="https://4ark.me/post/8b423d03.html"/>
    <id>https://4ark.me/post/8b423d03.html</id>
    <published>2019-01-16T09:21:24.000Z</published>
    <updated>2020-06-13T09:36:01.378Z</updated>
    
    <content type="html"><![CDATA[<div class="excerpt"><br>    理解<code>this</code>是我们要深入理解 JavaScript 中必不可少的一个步骤，同时只有理解了 <code>this</code>，你才能更加清晰地写出与自己预期一致的 JavaScript 代码。<br></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>理解<code>this</code>是我们要深入理解 JavaScript 中必不可少的一个步骤，同时只有理解了 <code>this</code>，你才能更加清晰地写出与自己预期一致的 JavaScript 代码。</p><p>本文是这系列的第三篇，往期文章：</p><ol><li><a href="https://juejin.im/post/5c386bd96fb9a04a03796f93" target="_blank" rel="noopener">理解 JavaScript 中的作用域</a></li><li><a href="https://juejin.im/post/5c3893bc6fb9a049d37f530f" target="_blank" rel="noopener">理解 JavaScript 中的闭包</a></li></ol><h2 id="什么是-this"><a href="#什么是-this" class="headerlink" title="什么是 this"></a>什么是 this</h2><h3 id="消除误解"><a href="#消除误解" class="headerlink" title="消除误解"></a>消除误解</h3><p>在解释什么是<code>this</code>之前，需要先纠正大部分人对<code>this</code>的误解，常见的误解有：</p><ol><li>指向函数自身。</li><li>指向它所在的作用域。</li></ol><blockquote><p>关于为何会误解的原因这里不多讲，这里只给出结论，有兴趣可以自行查询资料。</p></blockquote><p><code>this</code> 在任何情况下都不指向函数的词法作用域。你不能使用 <code>this</code> 来引用一个词法作用域内部的东西。</p><h3 id="this-到底是什么"><a href="#this-到底是什么" class="headerlink" title="this 到底是什么"></a>this 到底是什么</h3><p>排除了一些错误理解之后，我们来看看 <code>this</code>到底是一种什么样的机制。</p><p><code>this</code>是在运行时（<code>runtime</code>）进行绑定的，<strong>而不是在编写时绑定的</strong>，它的上下文（对象）取决于函数调用时的各种条件。<code>this</code>的绑定和函数声明的位置没有任何关系，<strong>只取决于函数的调用方式</strong>。</p><p>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。<strong><code>this</code>就是记录的其中一个属性</strong>，会在函数执行的过程中用到。（PS:所以<code>this</code>并不等价于执行上下文）</p><h2 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h2><p>前面 我们排除了一些对于 <code>this</code>的错误理解并且明白了每个函数的<code>this</code>是在调用时被绑定的，完全取决于函数的调用位置。</p><h3 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h3><p>通常来说，寻找调用位置就是寻找“函数被调用的位置“，其中最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。</p><p>下面我们来看看到底什么是调用栈和调用位置：</p><pre><code class="javascript">function foo(){    // 当前调用栈是：foo    // 因此，当前调用位置是全局作用域    console.log(&quot;foo&quot;);    bar(); // &lt;-- bar的调用位置}function bar(){    // 当前调用栈是foo -&gt; bar    console.log(&quot;bar&quot;);}foo(); // &lt;-- foo 的调用位置</code></pre><blockquote><p>你可以把调用栈想象成一个函数调用链， 就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。 另一个查看调用栈的方法是使用浏览器的调试工具。 绝大多数现代桌面浏览器都内置了开发者工具，其中包含 JavaScript 调试器。</p></blockquote><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>在找到调用位置后，则需要判定代码属于下面四种绑定规则中的哪一种，然后才能对<code>this</code>进行绑定。<br><strong>注意:</strong> <code>this</code>绑定的是上下文<strong>对象</strong>,<strong>并不是函数自身也不是函数的词法作用域</strong></p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>这是最常见的函数调用类型：<strong>独立函数调用</strong>：</p><p>对函数直接使用而不带任何修饰的函数引用进行调用，简单点一个函数直接是<code>func()</code>这样调用，不同于通过对象属性调用例如<code>obj.func()</code>，也没有通过new关键字<code>new Function()</code>，也没有通过<code>apply</code>、<code>call</code>、<code>bind</code>强制改变<code>this</code>指向。</p><p>当被用作独立函数调用时（不论这个函数在哪被调用，不管全局还是其他函数内），<code>this</code>默认指向到<code>Window</code>。（<strong>注意：在严格模式下<code>this</code>不再默认指向全局，而是<code>undefined</code></strong>）。</p><p>示例代码：</p><pre><code class="javascript">function foo(){    console.log(this.name);}var name = &quot;window&quot;;foo(); // window</code></pre><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a><strong>隐式绑定</strong></h4><p>函数被某个对象拥有或者包含，也就是函数被作为对象的属性所引用，例如<code>obj.func()</code>，此时<code>this</code>会绑定到该对象上，这就是隐式绑定。</p><p>示例代码：</p><pre><code class="javascript">var obj = {    name : &quot;obj&quot;,    foo : function(){        console.log(this.name);    }}obj.foo(); // obj</code></pre><p><strong>隐式丢失</strong>：</p><p>大部分的<code>this</code>绑定问题就是被“隐式绑定”的函数会丢失绑定对象，也就是说它会应用“默认绑定”，从而把<code>this</code>绑定到<code>Window</code>或<code>undefined</code>上，这取决于是否是严格模式。</p><p>最常见的情况就是把对象方法作为回调函数进行传递时：</p><pre><code class="javascript">var obj = {    name : &quot;obj&quot;,    foo : function(){        console.log(this.name);    }}var name = &quot;window&quot;;setTimeout(obj.foo,1000); // 一秒后输出 window</code></pre><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a><strong>显式绑定</strong></h4><p>我们可以通过<code>apply</code>、<code>call</code>、<code>bind</code>方法来显示地修改<code>this</code>的指向。</p><p>关于这三个方法的定义（它们第一个参数都是接受<code>this</code>的绑定对象）：</p><ol><li><code>apply</code>：调用函数，第二个参数传入一个参数数组。</li><li><code>call</code>：调用函数，其余参数正常传递。</li><li><code>bind</code>：返回一个已经绑定<code>this</code>的函数，其余参数正常传递。</li></ol><p>比如我们可以使用<code>bind</code>方法解决上一节“隐式丢失”中的例子：</p><pre><code class="javascript">var obj = {    name : &quot;obj&quot;,    foo : function(){        console.log(this.name);    }}var name = &quot;window&quot;;setTimeout(obj.foo.bind(obj),1000); // 一秒后输出 obj</code></pre><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建(或者说构造)一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的<code>this</code>。</li><li>如果函数没有返回其他对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ol><p>示例代码：</p><pre><code class="javascript">function foo(a) {   this.a = a;}var bar = new foo(2); console.log( bar.a ); // 2</code></pre><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>直接上结论:</p><blockquote><p>new绑定=显示绑定&gt;隐式绑定&gt;默认绑定</p></blockquote><p><strong>判断this：</strong><br> 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：</p><ol><li><p>使用new绑定，<code>this</code>绑定的是新创建的对象。</p><pre><code class="javascript">var bar = new foo();</code></pre></li><li><p>通过<code>call</code>之类的显式绑定，<code>this</code>绑定的是指定的对象。</p><pre><code class="javascript">var bar = foo.call(obj2);</code></pre></li><li><p>在某个上下文对象中调用(隐式绑定)，this 绑定的是那个上下文对象。</p><pre><code class="javascript">var bar = obj1.foo();</code></pre></li><li><p>如果都不是的话，使用默认绑定。<code>this</code>绑定到<code>Window</code>或<code>undefined</code>上，这取决于是否是严格模式。</p><pre><code class="javascript">var bar = foo();</code></pre><p>对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。</p></li></ol><h3 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h3><p>ES6 中介绍了一种无法使用上面四条规则的特殊函数类型：<strong>箭头函数</strong>。</p><p><strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。</strong>(而传统的this与函数作用域没有任何关系,它只与调用位置的上下文对象有关)。</p><p><strong>重要:</strong></p><ul><li>箭头函数最常用于回调函数中，例如事件处理器或者定时器.</li><li>箭头函数可以像<code>bind</code> 一样确保函数的<code>this</code>被绑定到指定对象</li><li>箭头函数用更常见的词法作用域取代了传统的<code>this</code>机制。</li></ul><p>示例代码：</p><pre><code class="javascript">var obj = {    name : &quot;obj&quot;,    foo : function(){        setTimeout(()=&gt;{            console.log(console.log(this.name)); // obj        },1000);    }}obj.foo();</code></pre><p>这在 ES6 之前是这样解决的：</p><pre><code class="javascript">var obj = {    name : &quot;obj&quot;,    foo : function(){        var self = this;        setTimeout(function(){            console.log(console.log(self.name)); // obj        },1000);    }}obj.foo();</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之如果要判断一个运行中函数的<code>this</code>绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断<code>this</code>的绑定对象。</p><ol><li>由new调用？绑定到新创建的对象。</li><li>由call或者apply(或者bind)调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认:在严格模式下绑定到<code>undefined</code>，否则绑定到全局对象。</li></ol><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 <code>this</code>，具体来说，箭头函数会继承外层函数调用的 <code>this</code>绑定(无论 <code>this</code>绑定到什么)。这其实和 ES6 之前代码中的 <code>self = this</code> 机制一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;excerpt&quot;&gt;&lt;br&gt;    理解&lt;code&gt;this&lt;/code&gt;是我们要深入理解 JavaScript 中必不可少的一个步骤，同时只有理解了 &lt;code&gt;this&lt;/code&gt;，你才能更加清晰地写出与自己预期一致的 JavaScript 代码。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://4ark.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
